using System;
using System.Drawing;
using System.Globalization;
using System.Text.RegularExpressions;
using System.Windows.Forms;

namespace CalculatorApp
{
    public partial class Form1 : Form
    {
        /// <summary>アプリ全体で使用する定数</summary>
        internal static class Constants
        {
            internal static class FontSize
            {
                internal const float ERROR_MESSAGE = 20.0f;
                internal const float RESULT_DISPLAY_BASE = 36f;
                internal const float EXPRESSION_DISPLAY_BASE = 10f;
                internal const float MIN_LIMIT = 14f;
                internal const float REDUCTION_STEP = 0.5f;
                internal const float SIZE_EPSILON = 0.1f;
            }

            internal static class Symbol
            {
                internal const string ADD = "+";
                internal const string SUBTRACT = "-";
                internal const string MULTIPLY = "×";
                internal const string DIVIDE = "÷";
                internal const string EQUAL = "=";
            }

            internal static class Numeric
            {
                internal const decimal INITIAL_VALUE = 0m;
                public const string ZERO_VALUE = "0";
                internal const decimal PERCENT_MULTIPLY = 0.01m;

                internal const int MAX_INTEGER_DISPLAY_DIGITS = 16;
                internal const int MAX_FRACTION_DISPLAY_DIGITS_LEADING_ZERO = 17;

                // 有効桁数・指数切替（Windows 電卓寄せ）
                public const int MAX_SIGNIFICANT_DIGITS = 17;
                internal static readonly decimal SCI_SMALL_THRESHOLD = 1e-9m;
                internal static readonly decimal SCI_LARGE_THRESHOLD = 1e16m;

                public const int EXP_SIGNIFICANT_DIGITS = 16; // 指数表示時の有効桁
            }

            internal static class ErrorMessage
            {
                internal const string OVERFLOW = "計算範囲を超えました";
                internal const string DIVIDE_BY_ZERO = "0で割ることはできません";
                internal const string UNDEFINED = "結果が定義されていません";
            }

            internal static class SpecialDisplay
            {
                internal const string NEGATE_FUNCTION = "negate";
            }
        }

        /// <summary>演算子の種類</summary>
        private enum OperatorType
        {
            NON, ADD, SUBTRACT, MULTIPLY, DIVIDE
        }

        /// <summary>計算処理の結果コード</summary>
        private enum ErrorCode
        {
            Success,
            Undefined,      // 0 ÷ 0
            DivideByZero    // n ÷ 0
        }

        // ===== 8.6: クラスのメンバ変数を m_ + lowerCamel に統一 =====
        private decimal m_firstValue = 0m;                    // 左辺
        private decimal m_secondValue = 0m;                   // 右辺（＝連打用）
        private bool m_textOverwrite = false;                 // 結果欄の上書き入力フラグ
        private bool m_numDot = false;                        // 小数点入力済み
        private bool m_isErrorState = false;                  // エラー状態
        private bool m_isClearEntry = false;                  // CE 直後か
        private decimal m_displayValue = Constants.Numeric.INITIAL_VALUE; // 内部の現在表示値
        private bool m_preserveFormatOnToggle = false;        // ±押下時にフォーマット保持
        private string m_lastUserTypedRaw = Constants.Numeric.ZERO_VALUE; // 直近の生入力（カンマなし）
        private bool m_lastActionWasPercent = false;          // 直前が％か
        private bool m_clearedExprAfterEqual = false;         // ＝直後に途中式を消したか
        private float m_defaultFontSize;                      // 結果欄フォント初期
        private float m_defaultExpressionFontSize;            // 式欄フォント初期
        private Button[] m_disabledButtonsOnError;            // エラー時に無効化するボタン
        private bool m_lockRhsAfterAutoOp = false;            // ％等で生成した右辺の編集ロック
        private decimal m_percentChainFactor = 0m;            // ＝直後％連打用: r/100
        private bool m_inPercentChainAfterEqual = false;      // ＝直後％連打中
        private OperatorType m_currentOperatorType = OperatorType.NON; // 現在の演算子

        /// <summary>
        /// フォームのコンストラクタ
        /// </summary>
        public Form1()
        {
            InitializeComponent();

            this.MaximumSize = this.Size;
            this.MinimumSize = this.Size;
            this.FormBorderStyle = FormBorderStyle.FixedSingle;
            this.MaximizeBox = false;

            m_disabledButtonsOnError = new Button[]
            {
                btnDot, btnTogglesign, btnPercent, btnPlus,
                btnMinus, btnMultiply, btnDivide
            };
        }

        /// <summary>
        /// フォームの初期化
        /// </summary>
        private void Form1_Load(object sender, EventArgs e)
        {
            this.Text = "電卓";

            textResult.Text = Constants.Numeric.ZERO_VALUE;
            m_textOverwrite = true;

            textResult.Font = new Font(textResult.Font.FontFamily, Constants.FontSize.RESULT_DISPLAY_BASE, textResult.Font.Style);
            textExpression.Font = new Font(textExpression.Font.FontFamily, Constants.FontSize.EXPRESSION_DISPLAY_BASE, textExpression.Font.Style);

            m_defaultFontSize = textResult.Font.Size;
            m_defaultExpressionFontSize = textExpression.Font.Size;

            // 内部値の初期同期
            m_displayValue = 0m;
            m_lastUserTypedRaw = "0";
        }

        private void textResult_TextChanged(object sender, EventArgs e)
        {
            AutoFitResultFont();
        }

        private void textExpression_TextChanged(object sender, EventArgs e)
        {
            // デザイナ参照維持のため空実装
        }

        // ===== イベントハンドラ =====

        private void btnNum_Click(object sender, EventArgs e)
        {
            Button btn = sender as Button;
            if (btn == null) return;

            if (IsError())
            {
                ResetCalculatorState();
            }
            OnDigitButton(btn.Text);
        }

        private void btnDot_Click(object sender, EventArgs e)
        {
            HandleInitialState();
            OnDotButton();
        }

        private void btnOperation_Click(object sender, EventArgs e)
        {
            Button btn = sender as Button;
            if (btn == null) return;

            OperatorType op;
            switch (btn.Text)
            {
                case Constants.Symbol.ADD: op = OperatorType.ADD; break;
                case Constants.Symbol.SUBTRACT: op = OperatorType.SUBTRACT; break;
                case Constants.Symbol.MULTIPLY: op = OperatorType.MULTIPLY; break;
                case Constants.Symbol.DIVIDE: op = OperatorType.DIVIDE; break;
                default: op = OperatorType.NON; break;
            }
            OnOperatorButton(op);
        }

        private void btnEnter_Click(object sender, EventArgs e)
        {
            OnEqualsButton();
        }

        private void btnPercent_Click(object sender, EventArgs e)
        {
            OnPercentButton();
        }

        private void btnClearEntry_Click(object sender, EventArgs e)
        {
            OnClearEntryButton();
        }

        private void btnClear_Click(object sender, EventArgs e)
        {
            OnClearButton();
        }

        private void btnBack_Click(object sender, EventArgs e)
        {
            OnBackspaceButton();
        }

        private void btnTogglesign_Click(object sender, EventArgs e)
        {
            OnToggleSignButton();
        }

        private void btnTopMost_Click(object sender, EventArgs e)
        {
            this.TopMost = !this.TopMost;
        }

        // ===== 入力系 =====

        private void OnDigitButton(string digit)
        {
            HandleInitialState();
            SetButtonsEnabled(true);
            m_lastActionWasPercent = false;

            if (m_textOverwrite && m_currentOperatorType != OperatorType.NON && !string.IsNullOrEmpty(textExpression.Text))
            {
                var expression = textExpression.Text.Trim();
                var opSymbol = GetOperatorSymbol(m_currentOperatorType);
                if (expression.IndexOf(opSymbol, StringComparison.Ordinal) >= 0)
                {
                    string left = FormatNumberForExpression(m_firstValue);
                    SetExprTo_Aop(left, opSymbol);
                }
            }

            if (IsExponentDisplay())
            {
                m_textOverwrite = true;
                m_numDot = false;
                m_lastUserTypedRaw = "0";
            }

            var currentRaw = m_lastUserTypedRaw;
            if (!IsInputValid(currentRaw, digit)) return;

            if (m_textOverwrite)
            {
                StartNewNumber(digit);
            }
            else
            {
                AppendDigit(digit);
            }

            TrySyncDisplayValueFromRaw();

            textResult.Text = InsertCommasIfNeeded(m_lastUserTypedRaw, m_numDot);
            m_isClearEntry = false;
            m_preserveFormatOnToggle = true;
        }

        private void OnDotButton()
        {
            HandleInitialState();
            m_lastActionWasPercent = false;

            if (m_numDot) return;

            if (m_textOverwrite)
            {
                SetRawAndRefresh("0.", overwrite: false);
            }
            else
            {
                SetRawAndRefresh(m_lastUserTypedRaw + ".", overwrite: false);
            }
            m_numDot = true;

            // "0." は内部的には 0 として保持
            string toParse = m_lastUserTypedRaw == "0." ? "0" : m_lastUserTypedRaw;
            TryParseIntoDisplayValue(toParse);

            m_preserveFormatOnToggle = true;
        }

        private void OnOperatorButton(OperatorType op)
        {
            if (IsError())
            {
                ResetCalculatorState();
                return;
            }

            try
            {
                if (HandleClearEntryThenOperator(op)) return;
                if (TryReplaceTrailingOperator(op)) return;
                if (StartNewChainAfterEqual(op)) return;
                if (HandlePercentThenOperator(op)) return;
                if (ChangeOperatorWhenRhsMissing(op)) return;
                if (ComputeThenSetNewOperator(op)) return;
            }
            catch (OverflowException)
            {
                SetErrorState(Constants.ErrorMessage.OVERFLOW);
            }
        }

        private void OnEqualsButton()
        {
            if (ShouldResetOnError())
            {
                SetButtonsEnabled(true);
                return;
            }

            try
            {
                decimal result = ProcessEqualsLogic();
                if (IsError()) return;

                DisplayNumber(result, true);

                m_preserveFormatOnToggle = false;
                m_lastActionWasPercent = false;
            }
            catch (InvalidOperationException ex)
            {
                SetErrorState(ex.Message);
            }
            catch (OverflowException)
            {
                SetErrorState(Constants.ErrorMessage.OVERFLOW);
            }
        }

        private void OnPercentButton()
        {
            if (ShouldResetOnError()) return;

            // = 表示中の %
            if (ExpressionEndsWithEqual())
            {
                ApplyPercentOnStandaloneResult(); // Windows電卓互換：+/- と ×/÷ で扱いが違う
                return;
            }

            // ＝直後％チェーン（単独値で％連打）
            if (m_currentOperatorType == OperatorType.NON && m_inPercentChainAfterEqual && m_percentChainFactor != 0m)
            {
                ContinuePercentChainAfterEqual();
                return;
            }

            // 二項演算中 A op B の %
            ApplyPercentInBinaryExpr();
        }

        private void OnClearEntryButton()
        {
            if (ShouldResetOnError())
            {
                SetButtonsEnabled(true);
                return;
            }

            string currentExpression = textExpression.Text != null ? textExpression.Text.Trim() : string.Empty;

            // ％直後に CE → 「A op」に戻す
            if (!ExpressionEndsWithEqual() && m_currentOperatorType != OperatorType.NON && m_lastActionWasPercent)
            {
                DisplayZeroResult();
                SetExprTo_Aop(FormatNumberForExpression(m_firstValue), GetOperatorSymbol(m_currentOperatorType));
                m_lastActionWasPercent = false;
                m_lockRhsAfterAutoOp = false;
                return;
            }

            // negate(result) 等の単独結果表示中（編集ロック）→ 全消去で 0
            if (m_lockRhsAfterAutoOp && m_currentOperatorType == OperatorType.NON && !ExpressionEndsWithEqual())
            {
                DisplayZeroResult();
                textExpression.Text = "";
                m_lockRhsAfterAutoOp = false;
                return;
            }

            if (ExpressionEndsWithEqual())
            {
                if (HasBinaryOperatorInExpression(currentExpression))
                {
                    ResetCalculatorState();
                    SetButtonsEnabled(true);
                    return;
                }

                DisplayZeroResult();
                ResetCalculationValues();
                return;
            }

            ClearCurrentEntry();
        }

        private void OnClearButton()
        {
            ResetAllState();
        }

        private void OnBackspaceButton()
        {
            if (ShouldResetOnError())
            {
                SetButtonsEnabled(true);
                return;
            }

            if (ExpressionEndsWithEqual())
            {
                textExpression.Text = "";
                m_textOverwrite = true;
                m_numDot = false;
                m_preserveFormatOnToggle = false;
                m_lastActionWasPercent = false;
                m_clearedExprAfterEqual = true;

                m_lastUserTypedRaw = "0";
                m_displayValue = 0m;
                return;
            }

            if (m_clearedExprAfterEqual) return;

            if (IsExponentDisplay())
            {
                // 指数表示からの Backspace は新規入力開始（Windows電卓互換）
                m_textOverwrite = true;
                m_numDot = false;
                textResult.Text = Constants.Numeric.ZERO_VALUE;

                m_lastUserTypedRaw = "0";
                m_displayValue = 0m;

                m_preserveFormatOnToggle = false;
                m_lastActionWasPercent = false;
                return;
            }

            if (m_textOverwrite) return;

            // 生バッファ 1 文字削除
            if (m_lastUserTypedRaw.Length > 0)
            {
                var newRaw = m_lastUserTypedRaw.Substring(0, m_lastUserTypedRaw.Length - 1);
                if (string.IsNullOrEmpty(newRaw) || newRaw == "-")
                {
                    m_lastUserTypedRaw = "0";
                    m_textOverwrite = true;
                    m_numDot = false;
                }
                else
                {
                    m_lastUserTypedRaw = newRaw;
                    m_numDot = m_lastUserTypedRaw.IndexOf(".", StringComparison.Ordinal) >= 0;
                }
            }
            else
            {
                ResetCalculatorState();
                return;
            }

            TrySyncDisplayValueFromRaw();
            textResult.Text = InsertCommasIfNeeded(m_lastUserTypedRaw, m_numDot);

            m_preserveFormatOnToggle = true;
            m_lastActionWasPercent = false;
        }

        private void OnToggleSignButton()
        {
            if (ShouldResetOnError()) return;

            string expression = (textExpression.Text != null ? textExpression.Text.Trim() : string.Empty);
            bool isNegateExpr = expression.StartsWith(Constants.SpecialDisplay.NEGATE_FUNCTION + "(", StringComparison.Ordinal);

            // ＝直後 or negate(...) 表示中 → negate 入れ子表記で更新（編集ロック）
            if (ExpressionEndsWithEqual() || isNegateExpr)
            {
                ApplyNegateOnStandaloneResult();
                return;
            }

            // A op の直後（右辺未入力）: B := negate(A)（右辺編集ロック）
            if (m_currentOperatorType != OperatorType.NON && m_textOverwrite)
            {
                ApplyNegateAsRhsOfBinary();
                return;
            }

            // それ以外：編集中の数値を単純反転（編集継続可）
            m_displayValue = -GetCurrentValue();
            DisplayNumber(m_displayValue, overwrite: false);
            m_preserveFormatOnToggle = false;
            m_lastActionWasPercent = false;
        }

        // ===== 演算・状態遷移のサブロジック =====

        private bool HandleClearEntryThenOperator(OperatorType op)
        {
            if (!m_isClearEntry) return false;

            m_currentOperatorType = op;
            SetExprTo_Aop(FormatNumberForExpression(m_firstValue), GetOperatorSymbol(m_currentOperatorType));
            DisplayNumber(m_firstValue, overwrite: true);

            m_isClearEntry = false;
            m_textOverwrite = true;
            m_numDot = false;
            m_lastActionWasPercent = false;
            m_preserveFormatOnToggle = false;
            m_lockRhsAfterAutoOp = false;
            return true;
        }

        private bool TryReplaceTrailingOperator(OperatorType op)
        {
            var curExpr = (textExpression.Text == null ? "" : textExpression.Text).Trim();
            if (!(m_textOverwrite && curExpr.Length > 0 && !curExpr.EndsWith(Constants.Symbol.EQUAL)))
            {
                return false;
            }

            string[] ops = { Constants.Symbol.ADD, Constants.Symbol.SUBTRACT, Constants.Symbol.MULTIPLY, Constants.Symbol.DIVIDE };
            foreach (var o in ops)
            {
                if (curExpr.EndsWith(o))
                {
                    textExpression.Text = curExpr.Substring(0, curExpr.Length - o.Length) + GetOperatorSymbol(op);
                    m_currentOperatorType = op;

                    m_lockRhsAfterAutoOp = false;
                    m_lastActionWasPercent = false;
                    m_textOverwrite = true;
                    m_numDot = false;
                    return true;
                }
            }
            return false;
        }

        private bool StartNewChainAfterEqual(OperatorType op)
        {
            if (!ExpressionEndsWithEqual()) return false;

            m_firstValue = GetCurrentValue();
            m_secondValue = Constants.Numeric.INITIAL_VALUE;
            m_currentOperatorType = op;

            UpdateExpressionDisplay(m_firstValue, m_currentOperatorType);
            DisplayNumber(m_firstValue, true);

            m_textOverwrite = true;
            m_numDot = false;
            m_lastActionWasPercent = false;
            m_preserveFormatOnToggle = false;
            m_lockRhsAfterAutoOp = false;
            return true;
        }

        private bool HandlePercentThenOperator(OperatorType op)
        {
            if (!(m_lastActionWasPercent && m_currentOperatorType != OperatorType.NON)) return false;

            var current = GetCurrentValue();
            PerformPendingCalculation(current);
            if (IsError()) return true;

            DisplayNumber(m_firstValue, true);
            m_currentOperatorType = op;
            UpdateExpressionDisplay(m_firstValue, m_currentOperatorType);

            m_textOverwrite = true;
            m_numDot = false;
            m_lastActionWasPercent = false;
            m_preserveFormatOnToggle = false;
            m_lockRhsAfterAutoOp = false;
            return true;
        }

        private bool ChangeOperatorWhenRhsMissing(OperatorType op)
        {
            if (!(m_textOverwrite && m_currentOperatorType != OperatorType.NON)) return false;

            m_currentOperatorType = op;
            UpdateExpressionDisplay(m_firstValue, m_currentOperatorType);

            m_textOverwrite = true;
            m_numDot = false;
            m_lastActionWasPercent = false;
            m_preserveFormatOnToggle = false;
            m_lockRhsAfterAutoOp = false;
            return true;
        }

        private bool ComputeThenSetNewOperator(OperatorType op)
        {
            var currentValue = GetCurrentValue();
            PerformPendingCalculation(currentValue);
            if (IsError()) return true;

            DisplayNumber(m_firstValue, true);
            m_currentOperatorType = op;
            UpdateExpressionDisplay(m_firstValue, m_currentOperatorType);

            m_textOverwrite = true;
            m_numDot = false;
            m_lastActionWasPercent = false;
            m_preserveFormatOnToggle = false;
            m_lockRhsAfterAutoOp = false;
            return true;
        }

        /// <summary>
        /// イコールキー押下時の最終確定。＝連打時は SecondValue を再利用。
        /// </summary>
        private decimal ProcessEqualsLogic()
        {
            decimal currentValue = GetCurrentValue();
            bool isFirstEqual = !ExpressionEndsWithEqual();

            if (m_currentOperatorType == OperatorType.NON)
            {
                m_secondValue = currentValue;
                textExpression.Text = string.Format("{0} {1}",
                    FormatNumberForExpression(currentValue), Constants.Symbol.EQUAL);
                m_firstValue = currentValue;
                return currentValue;
            }

            decimal left, right;
            if (isFirstEqual)
            {
                left = m_firstValue;
                right = currentValue;
                m_secondValue = currentValue;
            }
            else
            {
                left = m_firstValue;
                right = m_secondValue;
            }

            decimal result;

            if (m_currentOperatorType == OperatorType.DIVIDE)
            {
                decimal divResult;
                ErrorCode code = Divide(left, right, out divResult);
                if (code == ErrorCode.Undefined)
                {
                    SetErrorState(Constants.ErrorMessage.UNDEFINED);
                    return m_firstValue;
                }
                if (code == ErrorCode.DivideByZero)
                {
                    SetErrorState(Constants.ErrorMessage.DIVIDE_BY_ZERO);
                    return m_firstValue;
                }
                result = divResult;
            }
            else
            {
                result = Calculate(left, right, m_currentOperatorType);
            }

            m_firstValue = result;

            string opSymbol = GetOperatorSymbol(m_currentOperatorType);
            string leftExpr = FormatNumberForExpression(left);
            string rightExpr = FormatNumberForExpression(right);

            string curr = (textExpression.Text != null ? textExpression.Text.Trim() : string.Empty);

            if (!string.IsNullOrEmpty(curr) &&
                !curr.EndsWith(Constants.Symbol.EQUAL) &&
                curr.StartsWith(Constants.SpecialDisplay.NEGATE_FUNCTION + "(", StringComparison.Ordinal))
            {
                if (curr.EndsWith(opSymbol))
                    textExpression.Text = curr + " " + rightExpr + " " + Constants.Symbol.EQUAL;
                else
                    textExpression.Text = curr + " " + Constants.Symbol.EQUAL;
            }
            else
            {
                SetExprTo_AopB_Eq(leftExpr, opSymbol, rightExpr);
            }

            return result;
        }

        // ===== % / ± の切り出し（Windows 電卓互換仕様の要点コメント付き） =====

        /// <summary>
        /// Apply % on a standalone result shown right after '='.
        /// Windows Calculator compatible:
        /// - If the last op was +/−: first % press computes r * (r/100) and arms a chain factor (r/100).
        /// - If the last op was ×/÷: behaves as r/100.
        /// Subsequent % presses (chain) multiply by (r/100) repeatedly.
        /// </summary>
        private void ApplyPercentOnStandaloneResult()
        {
            decimal r = GetCurrentValue();

            if (m_currentOperatorType == OperatorType.ADD || m_currentOperatorType == OperatorType.SUBTRACT)
            {
                m_percentChainFactor = r * Constants.Numeric.PERCENT_MULTIPLY; // r/100
                decimal v = r * m_percentChainFactor;                           // r * (r/100)

                m_firstValue = v;
                m_secondValue = Constants.Numeric.INITIAL_VALUE;
                m_currentOperatorType = OperatorType.NON;

                DisplayNumber(v, true);
                textExpression.Text = FormatNumberForExpression(v);

                m_lastActionWasPercent = true;
                m_preserveFormatOnToggle = false;
                m_lockRhsAfterAutoOp = true;
                m_inPercentChainAfterEqual = true;   // 続く % は ×(r/100)
            }
            else
            {
                // ×/÷ の直後は r/100
                decimal v = CalculatePercent(r);

                m_firstValue = v;
                m_secondValue = Constants.Numeric.INITIAL_VALUE;
                m_currentOperatorType = OperatorType.NON;

                DisplayNumber(v, true);
                textExpression.Text = FormatNumberForExpression(v);

                m_lastActionWasPercent = true;
                m_preserveFormatOnToggle = false;
                m_lockRhsAfterAutoOp = true;
                m_inPercentChainAfterEqual = false;
                m_percentChainFactor = 0m;
            }
        }

        /// <summary>
        /// Continue % chain after '=': multiply current by (r/100) each time.
        /// </summary>
        private void ContinuePercentChainAfterEqual()
        {
            decimal cur = GetCurrentValue();
            decimal v = cur * m_percentChainFactor; // ×(r/100)

            m_firstValue = v;
            m_secondValue = Constants.Numeric.INITIAL_VALUE;

            DisplayNumber(v, true);
            textExpression.Text = FormatNumberForExpression(v);

            m_lastActionWasPercent = true;
            m_preserveFormatOnToggle = false;
            m_lockRhsAfterAutoOp = true;
        }

        /// <summary>
        /// In a binary expression A op B, applies % to B:
        /// - If op is +/−: B := A * (B/100)
        /// - If op is ×/÷: B := (B/100)
        /// Then preview-updates the expression display.
        /// </summary>
        private void ApplyPercentInBinaryExpr()
        {
            decimal rhsSource = m_textOverwrite ? m_firstValue : GetCurrentValue();
            decimal percent = CalculatePercent(rhsSource);

            decimal replacedB;
            if (m_currentOperatorType == OperatorType.ADD || m_currentOperatorType == OperatorType.SUBTRACT)
            {
                replacedB = m_firstValue * percent;
            }
            else
            {
                replacedB = percent;
            }

            SetExprTo_AopB(
                FormatNumberForExpression(m_firstValue),
                GetOperatorSymbol(m_currentOperatorType),
                FormatNumberForExpression(replacedB));

            DisplayNumber(replacedB, true);

            m_lastActionWasPercent = true;
            m_preserveFormatOnToggle = false;
            m_lockRhsAfterAutoOp = true;

            m_inPercentChainAfterEqual = false;
            m_percentChainFactor = 0m;
        }

        /// <summary>
        /// ＝直後（または negate(...) 表示中）に ± を押した場合の処理。
        /// negate(...) を入れ子にし、単独結果として表示（編集ロック）。
        /// </summary>
        private void ApplyNegateOnStandaloneResult()
        {
            decimal v = -GetCurrentValue();
            DisplayNumber(v, true);
            UpdateExpressionForToggleSign();
            m_preserveFormatOnToggle = false;
            m_lastActionWasPercent = false;
            m_lockRhsAfterAutoOp = true;   // 編集ロック
        }

        /// <summary>
        /// A op の直後（右辺未入力）に ± を押した場合：
        /// B := negate(A) として右辺を自動生成し、右辺を編集不可にする。
        /// </summary>
        private void ApplyNegateAsRhsOfBinary()
        {
            decimal a = m_firstValue;
            decimal b = -a;

            SetExprTo_AopB(
                FormatNumberForExpression(a),
                GetOperatorSymbol(m_currentOperatorType),
                $"{Constants.SpecialDisplay.NEGATE_FUNCTION}({FormatNumberForExpression(a)})"
            );

            m_displayValue = b;
            DisplayNumber(b, true); // 上書き開始
            m_preserveFormatOnToggle = false;
            m_lastActionWasPercent = false;
            m_lockRhsAfterAutoOp = true;    // 右辺は編集不可
        }

        // ===== 処理ヘルパー =====

        private static ErrorCode Divide(decimal numerator, decimal denominator, out decimal result)
        {
            if (denominator == 0)
            {
                result = 0;
                return numerator == 0 ? ErrorCode.Undefined : ErrorCode.DivideByZero;
            }

            result = numerator / denominator;
            return ErrorCode.Success;
        }

        private decimal Calculate(decimal left, decimal right, OperatorType type)
        {
            switch (type)
            {
                case OperatorType.ADD: return left + right;
                case OperatorType.SUBTRACT: return left - right;
                case OperatorType.MULTIPLY: return left * right;
                case OperatorType.DIVIDE: return left / right;
                default: return right;
            }
        }

        private void PerformPendingCalculation(decimal currentValue)
        {
            if (ExpressionEndsWithEqual() || m_currentOperatorType == OperatorType.NON)
            {
                m_firstValue = currentValue;
            }
            else
            {
                if (m_currentOperatorType == OperatorType.DIVIDE)
                {
                    decimal divResult;
                    ErrorCode code = Divide(m_firstValue, currentValue, out divResult);
                    if (code == ErrorCode.Undefined)
                    {
                        SetErrorState(Constants.ErrorMessage.UNDEFINED);
                        return;
                    }
                    if (code == ErrorCode.DivideByZero)
                    {
                        SetErrorState(Constants.ErrorMessage.DIVIDE_BY_ZERO);
                        return;
                    }
                    m_firstValue = divResult;
                }
                else
                {
                    decimal result = Calculate(m_firstValue, currentValue, m_currentOperatorType);
                    m_firstValue = result;
                }
            }
        }

        private void UpdateExpressionDisplay(decimal value, OperatorType type)
        {
            string op = GetOperatorSymbol(type);

            string expr = (textExpression.Text != null ? textExpression.Text.Trim() : string.Empty);
            if (expr.StartsWith(Constants.SpecialDisplay.NEGATE_FUNCTION + "(", StringComparison.Ordinal))
            {
                textExpression.Text = string.Format("{0} {1}", expr, op);
                return;
            }

            string displayStr;
            decimal abs = Math.Abs(value);

            if (abs != 0m && (abs < Constants.Numeric.SCI_SMALL_THRESHOLD || abs >= Constants.Numeric.SCI_LARGE_THRESHOLD))
            {
                displayStr = FormatExponential(value);
            }
            else
            {
                decimal rounded = RoundResult(value);
                displayStr = FormatNumberForDisplay(rounded);
            }

            SetExprTo_Aop(displayStr, op);
        }

        private decimal CalculatePercent(decimal value)
        {
            return value * Constants.Numeric.PERCENT_MULTIPLY;
        }

        private void DisplayNumber(decimal value, bool overwrite)
        {
            decimal rounded = RoundResult(value);
            string s = FormatNumberForDisplay(rounded);

            textResult.Text = s;
            if (!IsExponentDisplay()) UpdateTextResultWithCommas();

            m_textOverwrite = overwrite;
            m_numDot = false;

            // 内部表示値に反映（指数文字列はパースしない）
            m_displayValue = value;

            m_preserveFormatOnToggle = false;
            m_lastUserTypedRaw = IsExponentDisplay()
                ? m_displayValue.ToString("0.#############################", CultureInfo.InvariantCulture)
                : textResult.Text.Replace(",", "");
        }

        // ===== 表示/書式ユーティリティ =====

        private string InsertCommasIfNeeded(string raw, bool numDot)
        {
            // 生の編集テキストに 3桁区切り
            if (string.IsNullOrEmpty(raw) || raw == "-" || (raw == "0" && !numDot)) return raw;

            bool neg = raw.StartsWith("-");
            if (neg) raw = raw.Substring(1);

            int dot = raw.IndexOf('.');
            string intPart = dot >= 0 ? raw.Substring(0, dot) : raw;
            string fracPart = dot >= 0 ? raw.Substring(dot + 1) : "";

            decimal intValue;
            if (decimal.TryParse(intPart, NumberStyles.Number, CultureInfo.InvariantCulture, out intValue))
            {
                string intFmt = intValue.ToString("#,##0", CultureInfo.InvariantCulture);
                string newText = (dot >= 0) ? (intFmt + "." + fracPart) : intFmt;
                if (neg) newText = "-" + newText;
                return newText;
            }
            return raw;
        }

        private void UpdateTextResultWithCommas()
        {
            if (IsError()) return;
            if (IsExponentDisplay()) return;

            string raw = textResult.Text.Replace(",", "");
            bool hasDot = raw.IndexOf(".", StringComparison.Ordinal) >= 0;
            string formatted = InsertCommasIfNeeded(raw, hasDot);

            if (formatted != textResult.Text)
            {
                int fromEnd = textResult.Text.Length - textResult.SelectionStart;
                textResult.Text = formatted;
                textResult.SelectionStart = Math.Max(0, textResult.Text.Length - fromEnd);
            }
        }

        private string FormatNumberForExpression(decimal value)
        {
            decimal rounded = RoundResult(value);
            return FormatNumberForDisplay(rounded);
        }

        private static decimal Pow10(int k)
        {
            if (k == 0) return 1m;
            decimal p = 1m;
            if (k > 0) { for (int i = 0; i < k; i++) p *= 10m; }
            else { for (int i = 0; i < -k; i++) p /= 10m; }
            return p;
        }

        /// <summary>
        /// |x| の常用対数に基づく 10 進指数（正規化時の指数）を求める。
        /// 1 ≤ |mantissa| &lt; 10 となるような指数を返す。
        /// </summary>
        private static int DecimalBase10Exponent(decimal x)
        {
            decimal absValue = Math.Abs(x);
            if (absValue == 0m) return 0;

            if (absValue >= 1m)
            {
                string s = decimal.Truncate(absValue).ToString(CultureInfo.InvariantCulture);
                return s.Length - 1;
            }
            else
            {
                string s = absValue.ToString("0.#############################", CultureInfo.InvariantCulture);
                int dot = s.IndexOf('.');
                int zeros = CountLeadingZeros(s, dot);
                return -(zeros + 1); // 0.000123 → -4
            }
        }

        /// <summary>
        /// fixedStr の小数点以降の先頭 0 の個数を数える。
        /// </summary>
        private static int CountLeadingZeros(string fixedStr, int dotIndex)
        {
            if (dotIndex < 0) return 0;
            int zeros = 0;
            for (int i = dotIndex + 1; i < fixedStr.Length && fixedStr[i] == '0'; i++) zeros++;
            return zeros;
        }

        /// <summary>
        /// 指定した有効桁数で四捨五入（AwayFromZero）。
        /// 28桁スケール制限に配慮し、整数側/小数側のどちらで丸めるか自動判定。
        /// </summary>
        private static decimal RoundToSignificantDigits(decimal x, int n)
        {
            if (x == 0m) return 0m;
            int exp = DecimalBase10Exponent(x);        // 10^exp の桁に 1つ目の有効桁
            int scale = n - 1 - exp;                   // 小数点以下で丸めたい桁数

            if (scale < 0)
            {
                int k = -scale;
                return Math.Round(x / Pow10(k), 0, MidpointRounding.AwayFromZero) * Pow10(k);
            }
            else
            {
                int safeScale = scale > 28 ? 28 : scale;
                decimal rounded = Math.Round(x, safeScale, MidpointRounding.AwayFromZero);
                return rounded;
            }
        }

        /// <summary>
        /// Scientific 表示（Windows電卓寄せ）。仮数は 16 有効桁。仮数が整数なら末尾 '.' を付与。
        /// </summary>
        private string FormatExponential(decimal value)
        {
            const int SIG = Constants.Numeric.EXP_SIGNIFICANT_DIGITS; // 16
            if (value == 0m) return "0";

            // 1) 16桁相当で丸め
            decimal rounded = RoundToSignificantDigits(value, SIG);

            // 2) 正規化
            int exp = DecimalBase10Exponent(rounded);
            decimal mantissa = rounded / Pow10(exp);

            // 3) 仮数が 10 に到達した場合の再正規化
            if (Math.Abs(mantissa) >= 10m)
            {
                mantissa /= 10m;
                exp += 1;
            }

            // 4) 仮数の文字列（整数なら末尾 '.'）
            string mantissaStr;
            decimal mantissaAbsTrunc = decimal.Truncate(Math.Abs(mantissa));
            if (Math.Abs(mantissa) == mantissaAbsTrunc)
            {
                mantissaStr = (mantissa >= 0 ? "" : "-") + mantissaAbsTrunc.ToString("0", CultureInfo.InvariantCulture) + ".";
            }
            else
            {
                mantissaStr = mantissa.ToString("0.#############################", CultureInfo.InvariantCulture).TrimEnd('0');
            }

            // 5) 指数部
            string expStr = (exp >= 0 ? "+" : "") + exp.ToString(CultureInfo.InvariantCulture);

            return mantissaStr + "e" + expStr;
        }

        /// <summary>
        /// 通常表示文字列。必要なら指数表記へフォールバック。
        /// </summary>
        private string FormatNumberForDisplay(decimal value)
        {
            decimal abs = Math.Abs(value);
            if (abs == 0m) return Constants.Numeric.ZERO_VALUE;

            string fixedStr = value.ToString("0.#############################", CultureInfo.InvariantCulture);

            int dot = fixedStr.IndexOf('.');
            bool neg = (fixedStr[0] == '-');
            int intLen = (dot >= 0 ? dot : fixedStr.Length) - (neg ? 1 : 0);

            if (abs < 1m)
            {
                int leadingZeros = CountLeadingZeros(fixedStr, dot);
                int significantDigits = 0;
                for (int i = dot + 1 + leadingZeros; i < fixedStr.Length; i++)
                {
                    if (char.IsDigit(fixedStr[i])) significantDigits++;
                }

                // 有効数字が17桁以内なら小数表示
                if (significantDigits <= Constants.Numeric.MAX_SIGNIFICANT_DIGITS)
                    return fixedStr;

                // それ以外は指数表示
                return FormatExponential(value);
            }
            else
            {
                if (intLen > Constants.Numeric.MAX_INTEGER_DISPLAY_DIGITS)
                    return FormatExponential(value);
                return fixedStr;
            }
        }

        private decimal GetCurrentValue() => m_displayValue;

        private decimal RoundResult(decimal value)
        {
            decimal abs = Math.Abs(value);
            if (abs == 0m) return 0m;

            // 指数レンジは事前丸め禁止（表示でのみ丸め/指数化）
            if (abs < Constants.Numeric.SCI_SMALL_THRESHOLD || abs >= Constants.Numeric.SCI_LARGE_THRESHOLD)
                return value;

            if (abs > 0m && abs < 1m)
                return Math.Round(value, 16, MidpointRounding.AwayFromZero);

            if (abs >= 1m)
            {
                string integerPartStr = Math.Floor(abs).ToString(CultureInfo.InvariantCulture);
                int integerLength = integerPartStr.Length;
                int decimalPlacesToRound = 16 - integerLength;
                if (decimalPlacesToRound >= 0)
                    return Math.Round(value, decimalPlacesToRound, MidpointRounding.AwayFromZero);
            }
            return value;
        }

        private bool IsError() => m_isErrorState;

        private bool ExpressionEndsWithEqual()
        {
            return textExpression.Text.Length > 0 && textExpression.Text.EndsWith(Constants.Symbol.EQUAL);
        }

        private bool IsExponentDisplay()
        {
            string t = textResult.Text;
            return (t.IndexOf('e') >= 0 || t.IndexOf('E') >= 0);
        }

        private bool ShouldResetOnError()
        {
            if (m_isErrorState)
            {
                ResetCalculatorState();
                return true;
            }
            return false;
        }

        // ===== 入力検証/同期ヘルパー =====

        /// <summary>
        /// 生テキスト（m_lastUserTypedRaw）→ m_displayValue に同期（TryParse成功時のみ）。
        /// </summary>
        private void TrySyncDisplayValueFromRaw()
        {
            decimal parsedValue;
            if (decimal.TryParse(m_lastUserTypedRaw, NumberStyles.Any, CultureInfo.InvariantCulture, out parsedValue))
            {
                m_displayValue = parsedValue;
            }
        }

        /// <summary>
        /// 指定の raw を設定し、表示も更新。必要に応じて TryParse して内部値に反映。
        /// </summary>
        private void SetRawAndRefresh(string raw, bool overwrite)
        {
            m_lastUserTypedRaw = raw;
            textResult.Text = InsertCommasIfNeeded(m_lastUserTypedRaw, m_numDot);
            m_textOverwrite = overwrite;
            TrySyncDisplayValueFromRaw();
        }

        private void TryParseIntoDisplayValue(string raw)
        {
            decimal parsedValue;
            if (decimal.TryParse(raw, NumberStyles.Any, CultureInfo.InvariantCulture, out parsedValue))
            {
                m_displayValue = parsedValue;
            }
        }

        private void StartNewNumber(string digit)
        {
            m_lastUserTypedRaw = digit;
            textResult.Text = digit;
            m_textOverwrite = false;
            m_numDot = (digit == ".");

            string toParse = (digit == ".") ? "0" : m_lastUserTypedRaw;
            TryParseIntoDisplayValue(toParse);
        }

        private void AppendDigit(string digit)
        {
            m_lastUserTypedRaw += digit;
            textResult.Text = InsertCommasIfNeeded(m_lastUserTypedRaw, m_numDot);
            TrySyncDisplayValueFromRaw();
        }

        private bool IsInputValid(string currentText, string digit)
        {
            bool startsWithZeroDot = currentText.StartsWith("0.") || currentText.StartsWith("-0.");
            int maxDigits = startsWithZeroDot ? Constants.Numeric.MAX_FRACTION_DISPLAY_DIGITS_LEADING_ZERO : Constants.Numeric.MAX_INTEGER_DISPLAY_DIGITS;

            string nextText = m_textOverwrite ? digit : currentText + digit;
            int nextLength = nextText.Replace(".", "").Replace("-", "").Length;

            if (nextLength > maxDigits) return false;

            if (!m_textOverwrite && currentText == Constants.Numeric.ZERO_VALUE && digit == Constants.Numeric.ZERO_VALUE && !m_numDot)
            {
                return false;
            }

            return true;
        }

        // ===== 途中式の生成ユーティリティ =====

        private void SetExprTo_Aop(string a, string opSymbol)
        {
            textExpression.Text = $"{a} {opSymbol}";
        }

        private void SetExprTo_AopB(string a, string opSymbol, string b)
        {
            textExpression.Text = $"{a} {opSymbol} {b}";
        }

        private void SetExprTo_AopB_Eq(string a, string opSymbol, string b)
        {
            textExpression.Text = $"{a} {opSymbol} {b} {Constants.Symbol.EQUAL}";
        }

        private void UpdateExpressionForToggleSign()
        {
            string expr = (textExpression.Text != null ? textExpression.Text.Trim() : string.Empty);

            if (expr.EndsWith(Constants.Symbol.EQUAL))
            {
                int eq = expr.LastIndexOf(Constants.Symbol.EQUAL);
                string body = (eq >= 0 ? expr.Substring(0, eq) : expr).Trim();
                if (string.IsNullOrEmpty(body)) body = FormatNumberForExpression(m_firstValue);

                textExpression.Text = Constants.SpecialDisplay.NEGATE_FUNCTION + "(" + body + ")";
                return;
            }

            if (expr.StartsWith(Constants.SpecialDisplay.NEGATE_FUNCTION + "(", StringComparison.Ordinal))
            {
                textExpression.Text = Constants.SpecialDisplay.NEGATE_FUNCTION + "(" + expr + ")";
            }
        }

        private string GetOperatorSymbol(OperatorType type)
        {
            switch (type)
            {
                case OperatorType.ADD: return Constants.Symbol.ADD;
                case OperatorType.SUBTRACT: return Constants.Symbol.SUBTRACT;
                case OperatorType.MULTIPLY: return Constants.Symbol.MULTIPLY;
                case OperatorType.DIVIDE: return Constants.Symbol.DIVIDE;
                default: return string.Empty;
            }
        }

        // ===== 保守系（リセット/エラー/表示調整） =====

        private void DisplayZeroResult()
        {
            textResult.Text = Constants.Numeric.ZERO_VALUE;
            m_textOverwrite = true;
            m_numDot = false;

            m_displayValue = 0m;
            m_lastUserTypedRaw = "0";

            m_preserveFormatOnToggle = false;
            m_lastActionWasPercent = false;
        }

        private void ResetCalculationValues()
        {
            m_firstValue = Constants.Numeric.INITIAL_VALUE;
            m_secondValue = Constants.Numeric.INITIAL_VALUE;
            m_currentOperatorType = OperatorType.NON;
        }

        private void ClearCurrentEntry()
        {
            m_isClearEntry = true;
            DisplayZeroResult();
        }

        private void AutoFitResultFont()
        {
            float fontSize = m_defaultFontSize;
            FontFamily family = textResult.Font.FontFamily;
            FontStyle style = textResult.Font.Style;

            while (fontSize > Constants.FontSize.MIN_LIMIT)
            {
                using (Font trialFont = new Font(family, fontSize, style))
                {
                    Size proposedSize = new Size(int.MaxValue, int.MaxValue);
                    TextFormatFlags flags = TextFormatFlags.NoPadding | TextFormatFlags.SingleLine;
                    Size trialTextSize = TextRenderer.MeasureText(
                        textResult.Text,
                        trialFont,
                        proposedSize,
                        flags
                    );

                    if (trialTextSize.Width <= textResult.ClientSize.Width)
                    {
                        if (Math.Abs(textResult.Font.Size - fontSize) > Constants.FontSize.SIZE_EPSILON)
                        {
                            Font oldFont = textResult.Font;
                            textResult.Font = new Font(family, fontSize, style);
                            oldFont.Dispose();
                        }
                        return;
                    }
                }
                fontSize -= Constants.FontSize.SIZE_EPSILON;
            }

            if (Math.Abs(textResult.Font.Size - Constants.FontSize.MIN_LIMIT) > Constants.FontSize.REDUCTION_STEP)
            {
                Font oldFinalFont = textResult.Font;
                textResult.Font = new Font(family, Constants.FontSize.MIN_LIMIT, style);
                oldFinalFont.Dispose();
            }
        }

        private void SetButtonsEnabled(bool enabled)
        {
            foreach (Button btn in m_disabledButtonsOnError) btn.Enabled = enabled;
        }

        private void SetErrorState(string message)
        {
            textResult.Text = message;

            float sz = Constants.FontSize.ERROR_MESSAGE;
            textResult.Font = new Font(textResult.Font.FontFamily, sz, textResult.Font.Style);

            m_isErrorState = true;
            SetButtonsEnabled(false);
        }

        private void HandleInitialState()
        {
            if (m_isErrorState || ExpressionEndsWithEqual())
            {
                ResetCalculatorState();
                m_clearedExprAfterEqual = false;
            }
        }

        private void ResetAllState()
        {
            ResetCalculatorState();
            SetButtonsEnabled(true);
        }

        private void ResetCalculatorState()
        {
            InitializeValues();
            ClearTextFields();
            ResetFlags();
            ResetFonts();
        }

        private void InitializeValues()
        {
            m_firstValue = Constants.Numeric.INITIAL_VALUE;
            m_secondValue = Constants.Numeric.INITIAL_VALUE;
            m_currentOperatorType = OperatorType.NON;
            m_displayValue = 0m;
            m_lastUserTypedRaw = "0";
            m_percentChainFactor = 0m;
        }

        private void ClearTextFields()
        {
            textExpression.Text = "";
            textResult.Text = Constants.Numeric.ZERO_VALUE;
        }

        private void ResetFlags()
        {
            m_textOverwrite = true;
            m_numDot = false;
            m_isErrorState = false;
            m_isClearEntry = false;
            m_lastActionWasPercent = false;
            m_clearedExprAfterEqual = false;
            m_inPercentChainAfterEqual = false;
            m_lockRhsAfterAutoOp = false;
            m_preserveFormatOnToggle = false;
        }

        private void ResetFonts()
        {
            textResult.Font = new Font(textResult.Font.FontFamily, m_defaultFontSize, textResult.Font.Style);
            textExpression.Font = new Font(textExpression.Font.FontFamily, m_defaultExpressionFontSize, textExpression.Font.Style);
        }

        // ===== 補助 =====

        private bool HasBinaryOperatorInExpression(string expr)
        {
            if (string.IsNullOrEmpty(expr)) return false;

            int eq = expr.LastIndexOf(Constants.Symbol.EQUAL);
            string body = (eq >= 0) ? expr.Substring(0, eq) : expr;

            return body.Contains(Constants.Symbol.ADD) ||
                   body.Contains(Constants.Symbol.SUBTRACT) ||
                   body.Contains(Constants.Symbol.MULTIPLY) ||
                   body.Contains(Constants.Symbol.DIVIDE);
        }
    }
}
