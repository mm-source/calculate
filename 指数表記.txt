絶対値が ≥ 1e16 は指数表記。

絶対値が < 1e-3 のときは、
「小数点の後ろの先行ゼロの個数 + 有効桁数」≤ 17 桁 の場合だけ “固定小数” で表示（それ以外は指数表記）。
※これで

0.0004（先行ゼロ3 + 有効桁1 = 4 ≤ 17）→ 固定小数、

1/3000 = 3.333…e-4（先行ゼロ4 + 有効桁16 = 20 > 17）→ 指数、

0.0000000000000125（先行ゼロ13 + 有効桁4 = 17）→ 固定小数、

9.87654321e-16（先行ゼロ16 + 有効桁10 = 26 > 17）→ 指数、

0.0000000000000009（先行ゼロ16 + 有効桁1 = 17）→ 固定小数、
…がちょうど一致します。

それ以外（1e-3 ≤ |x| < 1e16）は固定小数。

この方針に沿って、既存コードの最小修正だけで仕上がる差分を示します。貼り替え・置換してください。

1) OnEqualsButton：判定関数を使わず常に DisplayNumber に委譲
// 置換前：ShouldUseExponentialNotation を呼ぶ実装
private void OnEqualsButton()
{
    if (ShouldResetOnError())
    {
        SetButtonsEnabled(true);
        return;
    }

    try
    {
        var result = ProcessEqualsLogic();
        if (IsError())
        {
            return;
        }

        // ← この分岐は廃止
        // 判定ロジックを呼び出す
        // if (ShouldUseExponentialNotation(result)) { ... } else { ... }

        // 常に DisplayNumber に委譲（内部で指数/固定を判定）
        DisplayNumber(result, true);

        m_preserveFormatOnToggle = false;
        m_lastActionWasPercent = false;
    }
    catch (InvalidOperationException ex)
    {
        SetErrorState(ex.Message);
    }
    catch (OverflowException)
    {
        SetErrorState(Constants.ErrorMessage.OVERFLOW);
    }
}


ShouldUseExponentialNotation は 未使用になるので、クラス内に残っていても害はありませんが、不要なら削除してOKです。

2) UpdateExpressionDisplay：式欄も同じ基準で表示
private void UpdateExpressionDisplay(decimal value, OperatorType type)
{
    var op = GetOperatorSymbol(type);
    var expr = (textExpression.Text != null ? textExpression.Text.Trim() : string.Empty);

    if (expr.StartsWith(Constants.SpecialDisplay.NEGATE_FUNCTION + "(", StringComparison.Ordinal))
    {
        textExpression.Text = string.Format("{0} {1}", expr, op);
        return;
    }

    // ← しきい値で分岐せず、統一フォーマッタを使用
    var rounded = RoundResult(value);
    var displayStr = FormatNumberForDisplay(rounded);

    textExpression.Text = string.Format("{0} {1}", displayStr, op);
}

3) FormatNumberForDisplay：小さい値の「17桁フィット」判定を実装
private string FormatNumberForDisplay(decimal value)
{
    var abs = Math.Abs(value);
    if (abs == 0m) return Constants.Numeric.ZERO_VALUE;

    // 大きすぎる値は指数
    if (abs >= Constants.Numeric.SCI_LARGE_THRESHOLD)
        return FormatExponential(value);

    // 小さい値は「先行ゼロ + 有効桁」<= 17 なら固定小数、超えるなら指数
    if (abs < Constants.Numeric.SCI_SMALL_THRESHOLD) // SCI_SMALL_THRESHOLD は 1e-3 のままでOK
    {
        // まず「有効桁数」で丸め（16 か 17 任意。ここでは 16 を採用）
        var rounded = RoundToSignificantDigits(value, Constants.Numeric.EXP_SIGNIFICANT_DIGITS); // 16
        var fixedStr = rounded.ToString("0.#############################", CultureInfo.InvariantCulture);

        // 小数部解析
        int dot = fixedStr.IndexOf('.');
        if (dot >= 0)
        {
            int leadingZeros = 0;
            for (int i = dot + 1; i < fixedStr.Length && fixedStr[i] == '0'; i++) leadingZeros++;

            int sigDigits = 0;
            for (int i = dot + 1 + leadingZeros; i < fixedStr.Length; i++)
                if (char.IsDigit(fixedStr[i])) sigDigits++;

            // 17桁ルール：先行ゼロ + 有効桁数 <= 17 なら固定小数を採用
            if (leadingZeros + sigDigits <= Constants.Numeric.MAX_FRACTIONAL_DIGITS /* 17 */)
                return fixedStr;
        }

        // フィットしなければ指数
        return FormatExponential(value);
    }

    // 通常レンジは固定小数
    return value.ToString("0.#############################", CultureInfo.InvariantCulture);
}


ポイント

小さい値（< 1e-3）だけ、「小数点以下の先行ゼロ数 + 有効桁数 ≤ 17」を満たすかを見ます。

満たせば固定小数（例：0.0004, 0.0000000000000125, 0.0000000000000009）、満たせなければ指数（例：3.333333333333333e-4, 9.000900090009001e-4, 9.87654321e-16）。

大きい値（≥ 1e16）は指数。中間（1e-3 ≤ |x| < 1e16）は固定小数。

4) そのままでOK（変更不要）

Constants.Numeric.SCI_SMALL_THRESHOLD = 1e-3m;（既存のまま）

Constants.Numeric.SCI_LARGE_THRESHOLD = 1e16m;（既存のまま）

EXP_SIGNIFICANT_DIGITS = 16;（mantissa 16桁相当で十分に一致）

FormatExponential（末尾 . の扱いなど既存の仕様で、提示例と整合します）

これで指定の例はこう出ます

1÷3 → 0.3333333333333333

1÷3000 → 3.333333333333333e-4

2÷5000 → 0.0004

6÷6666 → 9.000900090009001e-4

1÷8000000000000000 → 1.25e-16

1÷80000000000000 → 0.0000000000000125

56789÷1000000000000000 → 0.0000000000056789（※ご提示例は 1 桁ゼロが少ないようでしたが、挙動は固定小数になります）

0.987654321÷1000000000000000 → 9.87654321e-16

0.9÷1000000000000000 → 0.0000000000000009

必要なら、この判定を 式欄だけ“常に固定小数にしたい” といったバリエーションにもすぐ対応できます。その場合は UpdateExpressionDisplay 内で FormatNumberForDisplay の代わりに「固定小数専用フォーマッタ」を呼ぶだけでOKです。

あなた:
変更した点をまとめてください
ChatGPT:

了解！変更点をギュッとまとめました。

変更サマリ

表示判定の一本化

OnEqualsButton：指数/固定の分岐をやめ、常に DisplayNumber(result, true) に委譲。

これにより、結果欄の指数切替は FormatNumberForDisplay に統一。

式欄も同じ基準で整形

UpdateExpressionDisplay：独自の閾値分岐を廃止し、
var displayStr = FormatNumberForDisplay(RoundResult(value)); に変更。

結果欄と式欄で同じ表示規則が適用。

小さい値の“17桁フィット”ルールを実装（Windows電卓準拠）

FormatNumberForDisplay を改修。

|x| ≥ 1e16 → 指数表記。

|x| < 1e-3 → 「先行ゼロ個数 + 有効桁数 ≤ 17」なら固定小数、超えたら指数。

例：0.0004 は固定、3.333…e-4 は指数、0.0000000000000125 は固定。

1e-3 ≤ |x| < 1e16 → 固定小数。

小さい値のチェック時は RoundToSignificantDigits(value, 16) で仮丸めして判定の安定性を確保。

そのまま（変更不要）

Constants.Numeric.SCI_SMALL_THRESHOLD = 1e-3m、SCI_LARGE_THRESHOLD = 1e16m は現状維持。

EXP_SIGNIFICANT_DIGITS = 16 も現状維持。

FormatExponential の実装（仮数末尾の.付与など）も変更なし。

後片付け（任意）

ShouldUseExponentialNotation は未使用になるため、削除してOK（任意）。残しても動作影響なし。

この結果、提示いただいた期待表示（1/3000 → 3.333…e-4, 2/5000 → 0.0004, 1/8e15 → 1.25e-16 ほか）と一致するようになっています。