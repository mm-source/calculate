クラスのメンバ変数（8.6）：m_ プレフィックス + lowerCamel（例：m_firstValue）に統一

ローカル変数（8.7）：lowerCamel（例：currentRaw, roundedValue）に統一（現状ほぼOK）

セッション変数（8.8）：該当なし（Windowsフォーム単体のため）

定数（8.9）：現状ほぼ UPPER_SNAKE_CASE でOK。readonly も UPPER_SNAKE_CASE 維持で問題なし

英語名（8.10）：識別子は英語。エラーメッセージの“文字列中の日本語”はOK

メンバ変数：未適合 → 修正名（8.6）
種別	現在	望ましい名前（m_ + lowerCamel）
decimal	FirstValue	m_firstValue
decimal	SecondValue	m_secondValue
bool	TextOverwrite	m_textOverwrite
bool	NumDot	m_numDot
bool	IsErrorState	m_isErrorState
bool	IsClearEntry	m_isClearEntry
decimal	DisplayValue	m_displayValue
bool	PreserveFormatOnToggle	m_preserveFormatOnToggle
string	lastUserTypedRaw	m_lastUserTypedRaw
bool	lastActionWasPercent	m_lastActionWasPercent
bool	ClearedExprAfterEqual	m_clearedExprAfterEqual
float	defaultFontSize	m_defaultFontSize
float	defaultExpressionFontSize	m_defaultExpressionFontSize
Button[]	DisabledButtonsOnError	m_disabledButtonsOnError
bool	lockRhsAfterAutoOp	m_lockRhsAfterAutoOp
decimal	percentChainFactor	m_percentChainFactor
bool	inPercentChainAfterEqual	m_inPercentChainAfterEqual
OperatorType	currentOperatorType	m_currentOperatorType

補足

Constants は「定数コンテナ」クラス名なのでそのままでOK。

Constants 内の各 定数名は既に UPPER_SNAKE_CASE で概ね合格（SCI_SMALL_THRESHOLD などの static readonly も表記はOK）。

列挙型 OperatorType と列挙子名は例外規定がないためこのままでOK（業務規約があればそれに従う）。

ローカル変数：気になるポイント（8.7）

多くは lowerCamel で OK。以下の 一貫化 を推奨：

dv → valueParsed / parsedValue

cur → current

expr → expression

op / opSym → opType / opSymbol

mant / mantStr → mantissa / mantissaStr

ax → absValue

iv → intValue

いずれも 最初の文字だけ小文字、語頭は以降大文字 を守る（例：parsedValue, opSymbol）。

定数（8.9）

既に UPPER_SNAKE_CASE で統一されていて良い感じ。

public const / internal const / static readonly いずれも 命名は UPPER_SNAKE_CASE でOK。

値が記号（"×", "÷"）なのも問題なし（識別子が英語ならOK）。

英語（8.10）

すべての 識別子 は英語になっていてOK。

日本語 UI テキスト（エラーメッセージ文、フォームタイトル）はユーザー向け文字列なのでOK。

実用的な「部分リネーム例」（抜粋）
フィールド宣言部（Before → After）
- private decimal FirstValue = 0m;
- private decimal SecondValue = 0m;
- private bool TextOverwrite = false;
- private bool NumDot = false;
- private bool IsErrorState = false;
- private bool IsClearEntry = false;
- private decimal DisplayValue = Constants.Numeric.INITIAL_VALUE;
- private bool PreserveFormatOnToggle = false;
- private string lastUserTypedRaw = Constants.Numeric.ZERO_VALUE;
- private bool lastActionWasPercent = false;
- private bool ClearedExprAfterEqual = false;
- private float defaultFontSize;
- private float defaultExpressionFontSize;
- private Button[] DisabledButtonsOnError;
- private bool lockRhsAfterAutoOp = false;
- private decimal percentChainFactor = 0m;
- private bool inPercentChainAfterEqual = false;
- private OperatorType currentOperatorType = OperatorType.NON;
+ private decimal m_firstValue = 0m;
+ private decimal m_secondValue = 0m;
+ private bool m_textOverwrite = false;
+ private bool m_numDot = false;
+ private bool m_isErrorState = false;
+ private bool m_isClearEntry = false;
+ private decimal m_displayValue = Constants.Numeric.INITIAL_VALUE;
+ private bool m_preserveFormatOnToggle = false;
+ private string m_lastUserTypedRaw = Constants.Numeric.ZERO_VALUE;
+ private bool m_lastActionWasPercent = false;
+ private bool m_clearedExprAfterEqual = false;
+ private float m_defaultFontSize;
+ private float m_defaultExpressionFontSize;
+ private Button[] m_disabledButtonsOnError;
+ private bool m_lockRhsAfterAutoOp = false;
+ private decimal m_percentChainFactor = 0m;
+ private bool m_inPercentChainAfterEqual = false;
+ private OperatorType m_currentOperatorType = OperatorType.NON;

代表的な参照箇所の置換例
- if (IsError()) { ResetCalculatorState(); }
+ if (IsError()) { ResetCalculatorState(); }

- if (TextOverwrite)
+ if (m_textOverwrite)

- NumDot = true;
+ m_numDot = true;

- DisplayValue = dv;
+ m_displayValue = dv;

- lastUserTypedRaw
+ m_lastUserTypedRaw

- lastActionWasPercent
+ m_lastActionWasPercent

- currentOperatorType
+ m_currentOperatorType


実際は 全メソッド内の参照 を網羅的に m_ へ置換する必要がある。
Visual Studio の「シンボルのリネーム（F2）」を使うと 参照安全に一括変更 できて事故が少ない。

“安全にやり切る”ための手順（おすすめ）

バックアップ（ブランチ or コピー）

フィールドを上から順に F2 リネーム（FirstValue → m_firstValue …）

コントロール名（textResult などデザイナ生成）は触らない

ローカル変数の微修正（dv → parsedValue など）

ビルドして 名前衝突/見落とし を潰す

ユニット的に動作確認（%、±、指数表示、CE/C など）

仕上げに：チェックリスト（コピー用）

 メンバ変数は全部 m_ + lowerCamel になっている

 ローカル変数は lowerCamel（略号を避け、意味がわかる名前に）

 定数は UPPER_SNAKE_CASE（const も static readonly も）

 識別子は英語。UIテキストの日本語はOK

 デザイナ生成のコントロール名はリネームしていない

 ビルド通過 & 主要操作（+ - × ÷ = % ± CE C ←）の動作確認

必要なら、自動変換用の置換リスト（Find/Replace 用）も作るよ。
「このファイルにそのまま適用した差分（diff）を出して」と言ってくれれば、パッチ形式で出力する！

あなた:
8.6の意味は　クラスのメンバ変数とは
ChatGPT:

8.6 の「クラスのメンバ変数」は、そのクラスの内部に宣言され、各インスタンス（または型そのもの）に属する変数のことだよ。C# では一般に フィールド（field） と呼ぶ。

要点だけ

宣言場所：クラス本体（メソッドの外）で宣言

スコープ：そのクラス内部（アクセス修飾子で外部公開も可）

寿命：インスタンスが生きている間（static はアプリ終了まで）

呼び名：C# の用語では “フィールド”。ガイドラインでは “メンバ変数” と表現

命名規約(8.6)：m_ を先頭に付け、m_firstValue のように lowerCamel で続ける

あなたのコードでの例
メンバ変数（= フィールド：8.6 の対象）
private decimal FirstValue = 0m;
private decimal SecondValue = 0m;
private bool TextOverwrite = false;
private bool NumDot = false;
private bool IsErrorState = false;
private decimal DisplayValue = Constants.Numeric.INITIAL_VALUE;
private float defaultFontSize;
private Button[] DisabledButtonsOnError;
private OperatorType currentOperatorType = OperatorType.NON;


→ 8.6 に合わせるなら例：m_firstValue, m_secondValue, m_textOverwrite … のように m_ で統一。

ローカル変数（8.7 の対象：メソッドの中で宣言）
private void OnDigitButton(string digit)
{
    var currentRaw = lastUserTypedRaw;   // ← これはローカル変数（メソッド内）
    decimal dv;                          // ← 同上
}

定数（8.9 の対象）
internal static class Constants
{
    internal static class Numeric
    {
        public const int MAX_SIGNIFICANT_DIGITS = 17; // ← 定数
        internal static readonly decimal SCI_SMALL_THRESHOLD = 1e-9m; // ← 読み取り専用フィールドだが定数扱いの命名規約でOK
    }
}

プロパティ（補足：外部公開用のメンバ。今回はほぼ未使用）
public int Count { get; private set; }   // ← これはプロパティ（フィールドとは別物）

まとめ

メンバ変数＝フィールド：クラス直下で宣言する状態保持用の変数（8.6 の命名規約を適用）

ローカル変数：メソッド内だけで使う一時変数（8.7）

定数：不変の値（8.9）

プロパティ：get/set で公開するメンバ（命名は PascalCase が一般的）

必要なら、あなたのファイルに 実際の m_ リネーム差分（diff） を作って渡すよ。

あなた:
また自動とは
ChatGPT:

「また自動とは？」というのは、あなたが引用している 命名規約の表記のことですね。

たとえば JIS X 0008 風のコーディング規約などでは、各項目の最後に [自動] と書いてあることがあります。
これは、

自動チェック／自動修正ツールで対応可能な規則である

コードレビューで人間が逐一目視するのではなく、静的解析ツールやリンターで判定できる

という意味です。

具体例

8.6 クラスのメンバ変数
→ m_firstValue のように m_ プレフィックスを自動で付けられる（ツールで検出／置換可能）

8.7 ローカル変数
→ メソッド内の変数は lowerCamelCase かどうかをツールでチェックできる

8.9 定数
→ SAMPLE_CONSTANT_VALUE のように大文字スネークケースかどうかを自動で判定できる

まとめ

「自動」とは 規約順守をツールで機械的に検証できるものという意味です。
つまり、レビュー担当者の主観に頼らず、スタイルチェッカー（Roslyn Analyzers, StyleCop, ReSharper など）で一律にチェックできるルール、ということです。
