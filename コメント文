// ========== イベントハンドラ群 ==========

/// <summary>結果欄の自動フォント調整</summary>
private void textResult_TextChanged(object sender, EventArgs e)
{
    AutoFitResultFont();
}

private void textExpression_TextChanged(object sender, EventArgs e) { }

/// <summary>数字ボタン押下</summary>
private void btnNum_Click(object sender, EventArgs e)
{
    Button btn = sender as Button;
    if (btn == null) return;
    if (IsError()) ResetCalculatorState(); // エラーならリセット
    OnDigitButton(btn.Text);
}

/// <summary>小数点ボタン押下</summary>
private void btnDot_Click(object sender, EventArgs e)
{
    HandleInitialState(); // =直後やエラー時は初期化
    OnDotButton();
}

/// <summary>演算子ボタン押下</summary>
private void btnOperation_Click(object sender, EventArgs e)
{
    Button btn = sender as Button;
    if (btn == null) return;

    // 押された記号に応じて演算子を判定
    OperatorType op = btn.Text switch
    {
        "+" => OperatorType.ADD,
        "-" => OperatorType.SUBTRACT,
        "×" => OperatorType.MULTIPLY,
        "÷" => OperatorType.DIVIDE,
        _ => OperatorType.NON
    };
    OnOperatorButton(op);
}

/// <summary>イコールキー押下</summary>
private void btnEnter_Click(object sender, EventArgs e) => OnEqualsButton();

/// <summary>%キー押下</summary>
private void btnPercent_Click(object sender, EventArgs e) => OnPercentButton();

/// <summary>CEキー押下</summary>
private void btnClearEntry_Click(object sender, EventArgs e) => OnClearEntryButton();

/// <summary>Cキー押下</summary>
private void btnClear_Click(object sender, EventArgs e) => OnClearButton();

/// <summary>Backspaceキー押下</summary>
private void btnBack_Click(object sender, EventArgs e) => OnBackspaceButton();

/// <summary>±キー押下</summary>
private void btnTogglesign_Click(object sender, EventArgs e) => OnToggleSignButton();

/// <summary>最前面切替ボタン押下</summary>
private void btnTopMost_Click(object sender, EventArgs e) => this.TopMost = !this.TopMost;


// ========== 内部処理メソッド群 ==========

/// <summary>数字入力処理</summary>
private void OnDigitButton(string digit)
{
    HandleInitialState(); // =直後やエラー時は初期化
    SetButtonsEnabled(true);
    m_lastActionWasPercent = false;

    // 演算子直後は式を整形
    if (m_textOverwrite && m_currentOperatorType != OperatorType.NON && !string.IsNullOrEmpty(textExpression.Text))
    {
        var expr = textExpression.Text.Trim();
        var opSym = GetOperatorSymbol(m_currentOperatorType);
        if (expr.IndexOf(opSym, StringComparison.Ordinal) >= 0)
        {
            string left = FormatNumberForExpression(m_firstValue);
            textExpression.Text = $"{left} {opSym}";
        }
    }

    // 指数表示中は強制的にリセット
    if (IsExponentDisplay())
    {
        m_textOverwrite = true;
        m_numDot = false;
        m_lastUserTypedRaw = "0";
    }

    if (!IsInputValid(m_lastUserTypedRaw, digit)) return;

    if (m_textOverwrite)
        StartNewNumber(digit); // 新規数値開始
    else
        AppendDigit(digit);    // 末尾に追加

    if (decimal.TryParse(m_lastUserTypedRaw, NumberStyles.Any, CultureInfo.InvariantCulture, out decimal dv))
        m_displayValue = dv;

    textResult.Text = InsertCommasIfNeeded(m_lastUserTypedRaw, m_numDot);
    m_isClearEntry = false;
    m_preserveFormatOnToggle = true;
}

/// <summary>小数点入力処理</summary>
private void OnDotButton()
{
    HandleInitialState();
    m_lastActionWasPercent = false;

    if (m_numDot) return; // 重複入力禁止

    if (m_textOverwrite)
    {
        m_lastUserTypedRaw = "0.";
        textResult.Text = m_lastUserTypedRaw;
        m_textOverwrite = false;
    }
    else
    {
        m_lastUserTypedRaw += ".";
        textResult.Text = m_lastUserTypedRaw;
    }
    m_numDot = true;

    string parseStr = m_lastUserTypedRaw == "0." ? "0" : m_lastUserTypedRaw;
    if (decimal.TryParse(parseStr, NumberStyles.Any, CultureInfo.InvariantCulture, out decimal dv))
        m_displayValue = dv;

    m_preserveFormatOnToggle = true;
}

/// <summary>演算子処理</summary>
private void OnOperatorButton(OperatorType op)
{
    if (IsError()) { ResetCalculatorState(); return; }

    try
    {
        if (HandleClearEntryThenOperator(op)) return;    // CE直後の演算子
        if (TryReplaceTrailingOperator(op)) return;      // 演算子だけ差替
        if (StartNewChainAfterEqual(op)) return;         // =直後の新チェーン
        if (HandlePercentThenOperator(op)) return;       // %直後の演算子
        if (ChangeOperatorWhenRhsMissing(op)) return;    // 右辺未入力時
        if (ComputeThenSetNewOperator(op)) return;       // 通常計算後に新演算子
    }
    catch (OverflowException) { SetErrorState(Constants.ErrorMessage.OVERFLOW); }
}

/// <summary>=キー処理</summary>
private void OnEqualsButton()
{
    if (ShouldResetOnError()) { SetButtonsEnabled(true); return; }

    try
    {
        decimal result = ProcessEqualsLogic(); // 等式確定
        if (IsError()) return;
        DisplayNumber(result, true);
        m_preserveFormatOnToggle = false;
        m_lastActionWasPercent = false;
    }
    catch (InvalidOperationException ex) { SetErrorState(ex.Message); }
    catch (OverflowException) { SetErrorState(Constants.ErrorMessage.OVERFLOW); }
}

/// <summary>%キー処理</summary>
private void OnPercentButton()
{
    if (ShouldResetOnError()) return;

    string expr = textExpression.Text?.Trim() ?? "";
    bool isOnlyNumber = string.IsNullOrEmpty(expr) || decimal.TryParse(expr, out _);

    // 単独値のみなら0に戻す
    if (m_currentOperatorType == OperatorType.NON && isOnlyNumber && !m_lastActionWasPercent)
    {
        DisplayZeroResult();
        textExpression.Text = "0";
        ResetPercentFlags();
        return;
    }

    // =直後は特殊処理（加減算とそれ以外で分岐）
    if (ExpressionEndsWithEqual()) { HandlePercentAfterEqual(); return; }

    // %連打時の処理
    if (m_currentOperatorType == OperatorType.NON && m_inPercentChainAfterEqual && m_percentChainFactor != 0m)
    {
        decimal cur = GetCurrentValue();
        decimal v = cur * m_percentChainFactor;
        m_firstValue = v;
        m_secondValue = 0m;
        DisplayNumber(v, true);
        textExpression.Text = FormatNumberForExpression(v);
        m_lastActionWasPercent = true;
        m_preserveFormatOnToggle = false;
        m_lockRhsAfterAutoOp = true;
        return;
    }

    // A op B の場合は右辺を百分率に置換
    decimal rhsSource = m_textOverwrite ? m_firstValue : GetCurrentValue();
    decimal percent = CalculatePercent(rhsSource);
    decimal replacedB = (m_currentOperatorType == OperatorType.ADD || m_currentOperatorType == OperatorType.SUBTRACT)
        ? m_firstValue * percent : percent;

    textExpression.Text = $"{FormatNumberForExpression(m_firstValue)} {GetOperatorSymbol(m_currentOperatorType)} {FormatNumberForExpression(replacedB)}";
    DisplayNumber(replacedB, true);
    m_lastActionWasPercent = true;
    m_preserveFormatOnToggle = false;
    m_lockRhsAfterAutoOp = true;
    ResetPercentFlags();
}

/// <summary>CEキー処理</summary>
private void OnClearEntryButton()
{
    if (ShouldResetOnError()) { SetButtonsEnabled(true); return; }

    string expr = textExpression.Text?.Trim() ?? "";

    // %直後にCE → A op に戻す
    if (!ExpressionEndsWithEqual() && m_currentOperatorType != OperatorType.NON && m_lastActionWasPercent)
    {
        DisplayZeroResult();
        textExpression.Text = $"{FormatNumberForExpression(m_firstValue)} {GetOperatorSymbol(m_currentOperatorType)}";
        m_lastActionWasPercent = false;
        m_lockRhsAfterAutoOp = false;
        return;
    }

    // negate結果表示中にCE → 全消去
    if (m_lockRhsAfterAutoOp && m_currentOperatorType == OperatorType.NON && !ExpressionEndsWithEqual())
    {
        DisplayZeroResult();
        textExpression.Text = "";
        m_lockRhsAfterAutoOp = false;
        return;
    }

    // =直後のCE → 状態に応じてリセット
    if (ExpressionEndsWithEqual())
    {
        if (HasBinaryOperatorInExpression(expr)) { ResetCalculatorState(); SetButtonsEnabled(true); return; }
        DisplayZeroResult();
        ResetCalculationValues();
        return;
    }

    // 通常のCE
    ClearCurrentEntry();
}

/// <summary>Cキー処理</summary>
private void OnClearButton() => ResetAllState();

/// <summary>Backspace処理</summary>
private void OnBackspaceButton()
{
    if (ShouldResetOnError()) { SetButtonsEnabled(true); return; }

    if (ExpressionEndsWithEqual()) { HandleBackAfterEqual(); return; }
    if (m_clearedExprAfterEqual) return;
    if (IsExponentDisplay()) { ResetToZero(); return; }
    if (m_textOverwrite) return;

    // 末尾を削除
    if (m_lastUserTypedRaw.Length > 0)
    {
        string newRaw = m_lastUserTypedRaw[..^1];
        if (string.IsNullOrEmpty(newRaw) || newRaw == "-")
        {
            m_lastUserTypedRaw = "0";
            m_textOverwrite = true;
            m_numDot = false;
        }
        else
        {
            m_lastUserTypedRaw = newRaw;
            m_numDot = m_lastUserTypedRaw.Contains(".");
        }
    }
    else { ResetCalculatorState(); return; }

    if (decimal.TryParse(m_lastUserTypedRaw, NumberStyles.Any, CultureInfo.InvariantCulture, out decimal dv))
        m_displayValue = dv;
    textResult.Text = InsertCommasIfNeeded(m_lastUserTypedRaw, m_numDot);

    m_preserveFormatOnToggle = true;
    m_lastActionWasPercent = false;
}

/// <summary>±キー処理</summary>
private void OnToggleSignButton()
{
    if (ShouldResetOnError()) return;

    string expr = textExpression.Text?.Trim() ?? "";
    bool isNegateExpr = expr.StartsWith("negate(");

    // =直後やnegate式中
    if (ExpressionEndsWithEqual() || isNegateExpr)
    {
        decimal v = -GetCurrentValue();
        DisplayNumber(v, true);
        UpdateExpressionForToggleSign();
        m_preserveFormatOnToggle = false;
        m_lastActionWasPercent = false;
        m_lockRhsAfterAutoOp = true;
        return;
    }

    // A op の直後で右辺未入力 → negate(A) を右辺に仮置き
    if (m_currentOperatorType != OperatorType.NON && m_textOverwrite)
    {
        decimal a = m_firstValue;
        decimal b = -a;
        textExpression.Text = $"{FormatNumberForExpression(a)} {GetOperatorSymbol(m_currentOperatorType)} negate({FormatNumberForExpression(a)})";
        m_displayValue = b;
        DisplayNumber(b, true);
        m_preserveFormatOnToggle = false;
        m_lastActionWasPercent = false;
        m_lockRhsAfterAutoOp = true;
        return;
    }

    // 通常は現在値を反転
    m_displayValue = -GetCurrentValue();
    DisplayNumber(m_displayValue, false);
    m_preserveFormatOnToggle = false;
    m_lastActionWasPercent = false;
}

/// <summary>フォント自動縮小</summary>
private void AutoFitResultFont()
{
    float fontSize = m_defaultFontSize;
    FontFamily family = textResult.Font.FontFamily;
    FontStyle style = textResult.Font.Style;

    // 収まるまで段階的に縮小
    while (fontSize > Constants.FontSize.MIN_LIMIT)
    {
        using (Font trialFont = new Font(family, fontSize, style))
        {
            Size proposedSize = new Size(int.MaxValue, int.MaxValue);
            TextFormatFlags flags = TextFormatFlags.NoPadding | TextFormatFlags.SingleLine;
            Size trialTextSize = TextRenderer.MeasureText(textResult.Text, trialFont, proposedSize, flags);

            if (trialTextSize.Width <= textResult.ClientSize.Width)
            {
                if (Math.Abs(textResult.Font.Size - fontSize) > Constants.FontSize.SIZE_EPSILON)
                {
                    Font oldFont = textResult.Font;
                    textResult.Font = new Font(family, fontSize, style);
                    oldFont.Dispose();
                }
                return;
            }
        }
        fontSize -= Constants.FontSize.SIZE_EPSILON;
    }

    // 最小でも収まらない場合は強制的に最小値
    if (Math.Abs(textResult.Font.Size - Constants.FontSize.MIN_LIMIT) > Constants.FontSize.REDUCTION_STEP)
    {
        Font oldFinalFont = textResult.Font;
        textResult.Font = new Font(family, Constants.FontSize.MIN_LIMIT, style);
        oldFinalFont.Dispose();
    }
}



// ========== 内部メソッド（演算・表示・状態管理・補助） ==========

/// <summary>未確定の「A op current」を確定して A に畳み込む</summary>
private void PerformPendingCalculation(decimal currentValue)
{
    // =直後または演算子未選択 → 右辺だけが最新値なので A を更新
    if (ExpressionEndsWithEqual() || m_currentOperatorType == OperatorType.NON)
    {
        m_firstValue = currentValue;
        return;
    }

    // 除算だけは0/0・x/0をエラーコードで明示処理
    if (m_currentOperatorType == OperatorType.DIVIDE)
    {
        if (Divide(m_firstValue, currentValue, out decimal divResult) == ErrorCode.Undefined)
        { SetErrorState(Constants.ErrorMessage.UNDEFINED); return; }
        if (Divide(m_firstValue, currentValue, out divResult) == ErrorCode.DivideByZero)
        { SetErrorState(Constants.ErrorMessage.DIVIDE_BY_ZERO); return; }

        // 2回呼んだくないので結果を一度計算
        ErrorCode code = Divide(m_firstValue, currentValue, out divResult);
        if (code == ErrorCode.Success) m_firstValue = divResult;
        return;
    }

    // 加算・減算・乗算は通常計算
    m_firstValue = Calculate(m_firstValue, currentValue, m_currentOperatorType);
}

/// <summary>途中式表示を「値 + 演算子」の形に整える（見た目専用）</summary>
private void UpdateExpressionDisplay(decimal value, OperatorType type)
{
    string op = GetOperatorSymbol(type);
    string expr = textExpression.Text?.Trim() ?? "";

    // negate(...) で始まる式の場合は、式そのものに演算子を付与
    if (expr.StartsWith(Constants.SpecialDisplay.NEGATE_FUNCTION + "(", StringComparison.Ordinal))
    { textExpression.Text = $"{expr} {op}"; return; }

    // 値の見た目を決定（指数レンジは指数表記、そうでなければ固定小数）
    decimal abs = Math.Abs(value);
    string displayStr =
        (abs != 0m && (abs < Constants.Numeric.SCI_SMALL_THRESHOLD || abs >= Constants.Numeric.SCI_LARGE_THRESHOLD))
            ? FormatExponential(value)
            : FormatNumberForDisplay(RoundResult(value));

    textExpression.Text = $"{displayStr} {op}";
}

/// <summary>= の実体。初回 '=' と連続 '='（前回Bの再適用）を切り分けて確定</summary>
private decimal ProcessEqualsLogic()
{
    decimal currentValue = GetCurrentValue();            // 右辺候補
    bool isFirstEqual = !ExpressionEndsWithEqual();      // 初回 '=' か

    // 演算子がないときは単独値の等式にする
    if (m_currentOperatorType == OperatorType.NON)
    {
        m_secondValue = currentValue;
        textExpression.Text = $"{FormatNumberForExpression(currentValue)} {Constants.Symbol.EQUAL}";
        m_firstValue = currentValue;
        return currentValue;
    }

    // 初回 '=' は A op current、連続 '=' は A op m_secondValue
    decimal left = m_firstValue;
    decimal right;
    if (isFirstEqual) { right = currentValue; m_secondValue = currentValue; }
    else              { right = m_secondValue; }

    // 除算はエラーコードで安全に処理
    decimal result;
    if (m_currentOperatorType == OperatorType.DIVIDE)
    {
        ErrorCode code = Divide(left, right, out decimal divResult);
        if (code == ErrorCode.Undefined) { SetErrorState(Constants.ErrorMessage.UNDEFINED); return m_firstValue; }
        if (code == ErrorCode.DivideByZero) { SetErrorState(Constants.ErrorMessage.DIVIDE_BY_ZERO); return m_firstValue; }
        result = divResult;
    }
    else
    {
        result = Calculate(left, right, m_currentOperatorType);
    }

    m_firstValue = result; // 結果をAに保持（次の連続 '=' に備える）

    // 途中式表示を "A op B =" の形に（negate(...) 入れ子を壊さない）
    string opSym = GetOperatorSymbol(m_currentOperatorType);
    string leftExpr = FormatNumberForExpression(left);
    string rightExpr = FormatNumberForExpression(right);
    string curr = textExpression.Text?.Trim() ?? "";
    if (!string.IsNullOrEmpty(curr) &&
        !curr.EndsWith(Constants.Symbol.EQUAL) &&
        curr.StartsWith(Constants.SpecialDisplay.NEGATE_FUNCTION + "(", StringComparison.Ordinal))
    {
        textExpression.Text = curr.EndsWith(opSym)
            ? $"{curr} {rightExpr} {Constants.Symbol.EQUAL}"
            : $"{curr} {Constants.Symbol.EQUAL}";
    }
    else
    {
        textExpression.Text = $"{leftExpr} {opSym} {rightExpr} {Constants.Symbol.EQUAL}";
    }
    return result;
}

/// <summary>r→r/100（パーセント値）</summary>
private decimal CalculatePercent(decimal value) => value * Constants.Numeric.PERCENT_MULTIPLY;

/// <summary>内部値→表示（ここでのみ丸め・指数整形を行う）</summary>
private void DisplayNumber(decimal value, bool overwrite)
{
    // 通常領域はRoundResult→FormatNumberForDisplay、指数領域はFormatExponentialへ
    string s = FormatNumberForDisplay(RoundResult(value));
    textResult.Text = s;

    // 指数表示でなければ3桁区切りを適用
    if (!IsExponentDisplay()) UpdateTextResultWithCommas();

    // 入力状態フラグや内部値を更新
    m_textOverwrite = overwrite;
    m_numDot = false;
    m_displayValue = value;
    m_preserveFormatOnToggle = false;

    // 入力中テキストは「内部の真実」と分離して保持
    m_lastUserTypedRaw = IsExponentDisplay()
        ? m_displayValue.ToString("0.#############################", CultureInfo.InvariantCulture)
        : textResult.Text.Replace(",", "");
}

/// <summary>3桁区切りを必要に応じて挿入（編集中のraw文字列用）</summary>
private string InsertCommasIfNeeded(string raw, bool numDot)
{
    // "-", "0"（小数点未入力）はそのまま
    if (string.IsNullOrEmpty(raw) || raw == "-" || (raw == "0" && !numDot)) return raw;

    bool neg = raw.StartsWith("-");
    if (neg) raw = raw.Substring(1);

    int dot = raw.IndexOf('.'); // ← if前に宣言（指摘対応）
    string intPart = (dot >= 0) ? raw.Substring(0, dot) : raw;
    string fracPart = (dot >= 0) ? raw[(dot + 1)..] : "";

    // 整数部だけ3桁区切り
    if (decimal.TryParse(intPart, NumberStyles.Number, CultureInfo.InvariantCulture, out decimal iv))
    {
        string intFmt = iv.ToString("#,##0", CultureInfo.InvariantCulture);
        string newText = (dot >= 0) ? (intFmt + "." + fracPart) : intFmt;
        return neg ? "-" + newText : newText;
    }
    return raw;
}

/// <summary>結果欄に3桁区切りを適用（指数表示は除外）</summary>
private void UpdateTextResultWithCommas()
{
    if (IsError() || IsExponentDisplay()) return;

    string raw = textResult.Text.Replace(",", "");
    bool hasDot = raw.Contains(".");
    string formatted = InsertCommasIfNeeded(raw, hasDot);

    if (formatted != textResult.Text)
    {
        // キャレット位置を末尾からの相対で維持
        int fromEnd = textResult.Text.Length - textResult.SelectionStart;
        textResult.Text = formatted;
        textResult.SelectionStart = Math.Max(0, textResult.Text.Length - fromEnd);
    }
}

/// <summary>式用の見た目文字列（表示専用の丸め・整形）</summary>
private string FormatNumberForExpression(decimal value)
{
    return FormatNumberForDisplay(RoundResult(value));
}

/// <summary>10^k（decimalで安全に）</summary>
private static decimal Pow10(int k)
{
    if (k == 0) return 1m;
    decimal p = 1m;
    if (k > 0) { for (int i = 0; i < k; i++) p *= 10m; }
    else       { for (int i = 0; i < -k; i++) p /= 10m; }
    return p;
}

/// <summary>10進指数（x = mant*10^exp の exp を概算）</summary>
private static int DecimalBase10Exponent(decimal x)
{
    decimal ax = Math.Abs(x);
    if (ax == 0m) return 0;

    if (ax >= 1m)
    {
        // 整数部の桁数 - 1
        string s = decimal.Truncate(ax).ToString(CultureInfo.InvariantCulture);
        return s.Length - 1;
    }
    else
    {
        // 0.(0…0)d… の先行ゼロ数を数える
        string s = ax.ToString("0.#############################", CultureInfo.InvariantCulture);
        int dot = s.IndexOf('.');
        int zeros = 0;
        for (int i = dot + 1; i < s.Length && s[i] == '0'; i++) zeros++;
        return -(zeros + 1);
    }
}

/// <summary>有効桁 n で四捨五入（AwayFromZero）</summary>
private static decimal RoundToSignificantDigits(decimal x, int n)
{
    if (x == 0m) return 0m;
    int exp = DecimalBase10Exponent(x); // 10^exp に正規化したときの指数
    int scale = n - 1 - exp;            // 小数点以下に何桁残すか

    if (scale < 0)
    {
        // 整数側を丸める（10^{-scale}で割って0桁丸め→戻す）
        int k = -scale;
        return Math.Round(x / Pow10(k), 0, MidpointRounding.AwayFromZero) * Pow10(k);
    }
    else
    {
        // 小数側を丸める（decimalの小数桁上限は28）
        int safeScale = Math.Min(scale, 28);
        return Math.Round(x, safeScale, MidpointRounding.AwayFromZero);
    }
}

/// <summary>指数表示の文字列を生成（仮数は整数なら末尾'.'を付与）</summary>
private string FormatExponential(decimal value)
{
    const int SIG = Constants.Numeric.EXP_SIGNIFICANT_DIGITS; // 16桁
    if (value == 0m) return "0";

    // まず有効桁で丸め（仮数が約1.0〜9.9になるよう調整）
    decimal rounded = RoundToSignificantDigits(value, SIG);
    int exp = DecimalBase10Exponent(rounded);
    decimal mant = rounded / Pow10(exp);

    // 稀に10以上になることがあるので再調整
    if (Math.Abs(mant) >= 10m) { mant /= 10m; exp += 1; }

    // 仮数の文字列（整数なら末尾'.'を付加）
    string mantStr;
    decimal mantAbsTrunc = decimal.Truncate(Math.Abs(mant));
    if (Math.Abs(mant) == mantAbsTrunc)
        mantStr = (mant >= 0 ? "" : "-") + mantAbsTrunc.ToString("0", CultureInfo.InvariantCulture) + ".";
    else
        mantStr = mant.ToString("0.#############################", CultureInfo.InvariantCulture).TrimEnd('0');

    string expStr = (exp >= 0 ? "+" : "") + exp.ToString(CultureInfo.InvariantCulture);
    return mantStr + "e" + expStr;
}

/// <summary>通常表示の文字列化（指数レンジは指数表記）</summary>
private string FormatNumberForDisplay(decimal value)
{
    decimal abs = Math.Abs(value);
    if (abs == 0m) return Constants.Numeric.ZERO_VALUE;

    // 指数レンジは指数表記へ
    if (abs < Constants.Numeric.SCI_SMALL_THRESHOLD || abs >= Constants.Numeric.SCI_LARGE_THRESHOLD)
        return FormatExponential(value);

    // 固定小数での表現
    string fixedStr = value.ToString("0.#############################", CultureInfo.InvariantCulture);

    // 0<abs<1 の場合は先行0の個数で有効桁17以内なら小数で、超えるなら指数へ
    if (abs < 1m)
    {
        int dot = fixedStr.IndexOf('.'); // ← if前に宣言（指摘対応）
        int leadingZeros = 0;
        for (int i = dot + 1; i < fixedStr.Length && fixedStr[i] == '0'; i++) leadingZeros++;

        int significantDigits = 0;
        for (int i = dot + 1 + leadingZeros; i < fixedStr.Length; i++)
            if (char.IsDigit(fixedStr[i])) significantDigits++;

        return (significantDigits <= Constants.Numeric.MAX_SIGNIFICANT_DIGITS)
            ? fixedStr
            : FormatExponential(value);
    }
    else
    {
        // 整数桁が16桁を超える場合は指数表記
        bool neg = fixedStr[0] == '-';
        int dot = fixedStr.IndexOf('.'); // ← if前に宣言（指摘対応）
        int intLen = (dot >= 0 ? dot : fixedStr.Length) - (neg ? 1 : 0);
        return (intLen > Constants.Numeric.MAX_INTEGER_DISPLAY_DIGITS)
            ? FormatExponential(value)
            : fixedStr;
    }
}

/// <summary>現在の内部表示値（演算に使う唯一の真実）</summary>
private decimal GetCurrentValue() => m_displayValue;

/// <summary>表示用の丸め（指数レンジは丸めない）</summary>
private decimal RoundResult(decimal value)
{
    decimal abs = Math.Abs(value);
    if (abs == 0m) return 0m;

    // 指数レンジは素通し（指数表記側で制御）
    if (abs < Constants.Numeric.SCI_SMALL_THRESHOLD || abs >= Constants.Numeric.SCI_LARGE_THRESHOLD)
        return value;

    // 0<abs<1 → 小数16桁で丸め
    if (abs > 0m && abs < 1m)
        return Math.Round(value, 16, MidpointRounding.AwayFromZero);

    // abs>=1 → 有効桁16に合わせて小数桁数を決めて丸め
    int integerLength = Math.Floor(abs).ToString(CultureInfo.InvariantCulture).Length;
    int decimalPlacesToRound = 16 - integerLength;
    return (decimalPlacesToRound >= 0)
        ? Math.Round(value, decimalPlacesToRound, MidpointRounding.AwayFromZero)
        : value;
}

/// <summary>エラー状態か</summary>
private bool IsError() => m_isErrorState;

/// <summary>途中式が '=' で終わっているか</summary>
private bool ExpressionEndsWithEqual()
    => textExpression.Text.Length > 0 && textExpression.Text.EndsWith(Constants.Symbol.EQUAL);

/// <summary>結果表示が指数表記か</summary>
private bool IsExponentDisplay()
{
    string t = textResult.Text;
    return (t.IndexOf('e') >= 0 || t.IndexOf('E') >= 0);
}

/// <summary>エラー後は即時初期化する必要があるか</summary>
private bool ShouldResetOnError()
{
    if (!m_isErrorState) return false;
    ResetCalculatorState(); // エラー表示 → 初期化
    return true;
}

/// <summary>エラー時に無効化する対象キーの有効/無効を設定</summary>
private void SetButtonsEnabled(bool enabled)
{
    foreach (Button btn in m_disabledButtonsOnError) btn.Enabled = enabled;
}

/// <summary>エラー状態へ遷移（メッセージ・フォント・ボタン状態を更新）</summary>
private void SetErrorState(string message)
{
    textResult.Text = message;
    textResult.Font = new Font(textResult.Font.FontFamily, Constants.FontSize.ERROR_MESSAGE, textResult.Font.Style);
    m_isErrorState = true;
    SetButtonsEnabled(false);
}

/// <summary>エラーや '=' 直後に必要な初期化（次の入力に備える）</summary>
private void HandleInitialState()
{
    if (m_isErrorState || ExpressionEndsWithEqual())
    {
        ResetCalculatorState();
        m_clearedExprAfterEqual = false;
    }
}

/// <summary>全状態を初期化（Cキー）</summary>
private void ResetAllState()
{
    ResetCalculatorState();
    SetButtonsEnabled(true);
}

/// <summary>電卓の内部状態を初期値に戻す</summary>
private void ResetCalculatorState()
{
    InitializeValues();   // 数値レジスタを初期化
    ClearTextFields();    // 表示テキストを初期化
    ResetFlags();         // 入力フラグを初期化
    ResetFonts();         // フォントを初期化
}

/// <summary>数値レジスタ初期化</summary>
private void InitializeValues()
{
    m_firstValue = 0m;
    m_secondValue = 0m;
    m_currentOperatorType = OperatorType.NON;
    m_displayValue = 0m;
    m_lastUserTypedRaw = "0";
    m_percentChainFactor = 0m;
}

/// <summary>表示テキスト初期化</summary>
private void ClearTextFields()
{
    textExpression.Text = "";
    textResult.Text = Constants.Numeric.ZERO_VALUE;
}

/// <summary>入力・編集状態の各種フラグ初期化</summary>
private void ResetFlags()
{
    m_textOverwrite = true;
    m_numDot = false;
    m_isErrorState = false;
    m_isClearEntry = false;
    m_lastActionWasPercent = false;
    m_clearedExprAfterEqual = false;
    m_inPercentChainAfterEqual = false;
}

/// <summary>フォントを既定サイズへ戻す</summary>
private void ResetFonts()
{
    textResult.Font = new Font(textResult.Font.FontFamily, m_defaultFontSize, textResult.Font.Style);
    textExpression.Font = new Font(textExpression.Font.FontFamily, m_defaultExpressionFontSize, textExpression.Font.Style);
}

// ========== 分岐ハンドラ（OnOperatorButton の下請け） ==========

/// <summary>CE直後に演算子が来た → 「A op」に戻す</summary>
private bool HandleClearEntryThenOperator(OperatorType op)
{
    if (!m_isClearEntry) return false;

    m_currentOperatorType = op;
    textExpression.Text = $"{FormatNumberForExpression(m_firstValue)} {GetOperatorSymbol(m_currentOperatorType)}";
    DisplayNumber(m_firstValue, true); // 右辺クリアなのでAを表示

    // 入力開始状態へ
    m_isClearEntry = false;
    m_textOverwrite = true;
    m_numDot = false;
    m_lastActionWasPercent = false;
    m_preserveFormatOnToggle = false;
    m_lockRhsAfterAutoOp = false;
    return true;
}

/// <summary>演算子で終端しているとき、新しい演算子に差し替え</summary>
private bool TryReplaceTrailingOperator(OperatorType op)
{
    string curExpr = (textExpression.Text ?? "").Trim();
    if (!(m_textOverwrite && curExpr.Length > 0 && !curExpr.EndsWith(Constants.Symbol.EQUAL)))
        return false;

    string[] ops = { Constants.Symbol.ADD, Constants.Symbol.SUBTRACT, Constants.Symbol.MULTIPLY, Constants.Symbol.DIVIDE };
    foreach (var o in ops)
    {
        if (curExpr.EndsWith(o))
        {
            textExpression.Text = curExpr.Substring(0, curExpr.Length - o.Length) + GetOperatorSymbol(op);
            m_currentOperatorType = op;

            // 右辺は未入力のままなので入力開始へ
            m_lockRhsAfterAutoOp = false;
            m_lastActionWasPercent = false;
            m_textOverwrite = true;
            m_numDot = false;
            return true;
        }
    }
    return false;
}

/// <summary>'=' 直後 → 直近結果をAに据え、新しいチェーン開始</summary>
private bool StartNewChainAfterEqual(OperatorType op)
{
    if (!ExpressionEndsWithEqual()) return false;

    m_firstValue = GetCurrentValue();
    m_secondValue = 0m;
    m_currentOperatorType = op;

    UpdateExpressionDisplay(m_firstValue, m_currentOperatorType);
    DisplayNumber(m_firstValue, true);

    // 次の右辺入力へ
    m_textOverwrite = true;
    m_numDot = false;
    m_lastActionWasPercent = false;
    m_preserveFormatOnToggle = false;
    m_lockRhsAfterAutoOp = false;
    return true;
}

/// <summary>'%’直後に演算子 → 先に確定計算してから新演算子へ</summary>
private bool HandlePercentThenOperator(OperatorType op)
{
    if (!(m_lastActionWasPercent && m_currentOperatorType != OperatorType.NON)) return false;

    decimal cur = GetCurrentValue();
    PerformPendingCalculation(cur); // A ← A op (B from %)
    if (IsError()) return true;

    DisplayNumber(m_firstValue, true);
    m_currentOperatorType = op;
    UpdateExpressionDisplay(m_firstValue, m_currentOperatorType);

    // 入力開始へ
    m_textOverwrite = true;
    m_numDot = false;
    m_lastActionWasPercent = false;
    m_preserveFormatOnToggle = false;
    m_lockRhsAfterAutoOp = false;
    return true;
}

/// <summary>「A op」で右辺未入力のまま別op → 演算子だけ置換</summary>
private bool ChangeOperatorWhenRhsMissing(OperatorType op)
{
    if (!(m_textOverwrite && m_currentOperatorType != OperatorType.NON)) return false;

    m_currentOperatorType = op;
    UpdateExpressionDisplay(m_firstValue, m_currentOperatorType);

    m_textOverwrite = true;
    m_numDot = false;
    m_lastActionWasPercent = false;
    m_preserveFormatOnToggle = false;
    m_lockRhsAfterAutoOp = false;
    return true;
}

/// <summary>「A op B」が揃っている → 一度計算してから新演算子に切替</summary>
private bool ComputeThenSetNewOperator(OperatorType op)
{
    decimal currentValue = GetCurrentValue(); // B
    PerformPendingCalculation(currentValue);  // A ← A op B
    if (IsError()) return true;

    DisplayNumber(m_firstValue, true);
    m_currentOperatorType = op;
    UpdateExpressionDisplay(m_firstValue, m_currentOperatorType);

    m_textOverwrite = true;
    m_numDot = false;
    m_lastActionWasPercent = false;
    m_preserveFormatOnToggle = false;
    m_lockRhsAfterAutoOp = false;
    return true;
}

// ========== 入力検査・式解析などの補助 ==========

/// <summary>式に2項演算子が含まれているか（'=’より前のみ検査）</summary>
private bool HasBinaryOperatorInExpression(string expr)
{
    if (string.IsNullOrEmpty(expr)) return false;
    int eq = expr.LastIndexOf(Constants.Symbol.EQUAL);
    string body = (eq >= 0) ? expr.Substring(0, eq) : expr;
    return body.Contains(Constants.Symbol.ADD) ||
           body.Contains(Constants.Symbol.SUBTRACT) ||
           body.Contains(Constants.Symbol.MULTIPLY) ||
           body.Contains(Constants.Symbol.DIVIDE);
}

/// <summary>表示を0にして内部・入力状態を同期</summary>
private void DisplayZeroResult()
{
    textResult.Text = Constants.Numeric.ZERO_VALUE;
    m_textOverwrite = true;
    m_numDot = false;
    m_displayValue = 0m;
    m_lastUserTypedRaw = "0";
    m_preserveFormatOnToggle = false;
    m_lastActionWasPercent = false;
}

/// <summary>計算用レジスタを初期値に（A,B,op）</summary>
private void ResetCalculationValues()
{
    m_firstValue = 0m;
    m_secondValue = 0m;
    m_currentOperatorType = OperatorType.NON;
}

/// <summary>現在の数値だけをクリア（式は維持）</summary>
private void ClearCurrentEntry()
{
    m_isClearEntry = true;
    DisplayZeroResult();
}

/// <summary>=直後の ± 表示を negate(...) の入れ子で更新</summary>
private void UpdateExpressionForToggleSign()
{
    string expr = textExpression.Text?.Trim() ?? "";
    if (expr.EndsWith(Constants.Symbol.EQUAL))
    {
        string formattedResult = FormatNumberForExpression(m_firstValue);
        textExpression.Text = $"{Constants.SpecialDisplay.NEGATE_FUNCTION}({formattedResult})";
        return;
    }
    if (expr.StartsWith(Constants.SpecialDisplay.NEGATE_FUNCTION + "(", StringComparison.Ordinal))
    {
        textExpression.Text = $"{Constants.SpecialDisplay.NEGATE_FUNCTION}({expr})";
    }
}

/// <summary>=直後の%（加減算は r×(r/100)、それ以外は r/100）</summary>
private void HandlePercentAfterEqual()
{
    decimal r = GetCurrentValue();

    if (m_currentOperatorType == OperatorType.ADD || m_currentOperatorType == OperatorType.SUBTRACT)
    {
        // 加減算チェーン：v = r * (r/100)／連打用係数も保持
        m_percentChainFactor = r * Constants.Numeric.PERCENT_MULTIPLY;
        decimal v = r * m_percentChainFactor;

        m_firstValue = v; m_secondValue = 0m; m_currentOperatorType = OperatorType.NON;
        DisplayNumber(v, true);
        textExpression.Text = FormatNumberForExpression(v);

        m_lastActionWasPercent = true;
        m_preserveFormatOnToggle = false;
        m_lockRhsAfterAutoOp = true;
        m_inPercentChainAfterEqual = true;
    }
    else
    {
        // 乗除など：単純に r/100
        decimal v = CalculatePercent(r);

        m_firstValue = v; m_secondValue = 0m; m_currentOperatorType = OperatorType.NON;
        DisplayNumber(v, true);
        textExpression.Text = FormatNumberForExpression(v);

        m_lastActionWasPercent = true;
        m_preserveFormatOnToggle = false;
        m_lockRhsAfterAutoOp = true;
        m_inPercentChainAfterEqual = false;
        m_percentChainFactor = 0m;
    }
}

/// <summary>%連打系フラグをクリア</summary>
private void ResetPercentFlags()
{
    m_inPercentChainAfterEqual = false;
    m_percentChainFactor = 0m;
}

/// <summary>=直後のBackspace：式を消して0に戻す（次入力へ）</summary>
private void HandleBackAfterEqual()
{
    textExpression.Text = "";
    m_textOverwrite = true;
    m_numDot = false;
    m_preserveFormatOnToggle = false;
    m_lastActionWasPercent = false;
    m_clearedExprAfterEqual = true;

    m_lastUserTypedRaw = "0";
    m_displayValue = 0m;
}

/// <summary>指数表示など安全に1文字削除できない状況で0に戻す</summary>
private void ResetToZero()
{
    m_textOverwrite = true;
    m_numDot = false;
    textResult.Text = Constants.Numeric.ZERO_VALUE;
    m_lastUserTypedRaw = "0";
    m_displayValue = 0m;
    m_preserveFormatOnToggle = false;
    m_lastActionWasPercent = false;
}

/// <summary>桁数・小数点・先頭ゼロなどの入力検査</summary>
private bool IsInputValid(string currentText, string digit)
{
    bool startsWithZeroDot = currentText.StartsWith("0.") || currentText.StartsWith("-0.");
    int maxDigits = startsWithZeroDot
        ? Constants.Numeric.MAX_FRACTION_DISPLAY_DIGITS_LEADING_ZERO
        : Constants.Numeric.MAX_INTEGER_DISPLAY_DIGITS;

    string nextText = m_textOverwrite ? digit : currentText + digit;
    int nextLength = nextText.Replace(".", "").Replace("-", "").Length;
    if (nextLength > maxDigits) return false;

    // "0" の連続入力を抑止（小数点入力前のみ）
    if (!m_textOverwrite && currentText == "0" && digit == "0" && !m_numDot) return false;

    return true;
}

/// <summary>新規数値の開始（"0." 特例を加味して内部値を更新）</summary>
private void StartNewNumber(string digit)
{
    m_lastUserTypedRaw = digit;
    textResult.Text = digit;
    m_textOverwrite = false;
    m_numDot = (digit == ".");

    string parseStr = (m_lastUserTypedRaw == ".") ? "0" : m_lastUserTypedRaw;
    if (decimal.TryParse(parseStr, NumberStyles.Any, CultureInfo.InvariantCulture, out decimal dv))
        m_displayValue = dv;
}

/// <summary>編集中テキストの末尾に数字を追加し内部値を同期</summary>
private void AppendDigit(string digit)
{
    m_lastUserTypedRaw += digit;
    textResult.Text = InsertCommasIfNeeded(m_lastUserTypedRaw, m_numDot);
    if (decimal.TryParse(m_lastUserTypedRaw, NumberStyles.Any, CultureInfo.InvariantCulture, out decimal dv))
        m_displayValue = dv;
}

/// <summary>演算子に対応する記号</summary>
private string GetOperatorSymbol(OperatorType type)
{
    return type switch
    {
        OperatorType.ADD => Constants.Symbol.ADD,
        OperatorType.SUBTRACT => Constants.Symbol.SUBTRACT,
        OperatorType.MULTIPLY => Constants.Symbol.MULTIPLY,
        OperatorType.DIVIDE => Constants.Symbol.DIVIDE,
        _ => string.Empty
    };
}

/// <summary>加減乗除の実装</summary>
private decimal Calculate(decimal left, decimal right, OperatorType type)
{
    return type switch
    {
        OperatorType.ADD => left + right,
        OperatorType.SUBTRACT => left - right,
        OperatorType.MULTIPLY => left * right,
        OperatorType.DIVIDE => left / right, // Divide()経由で扱う場面もあり
        _ => right
    };
}

/// <summary>除算の安全版（0/0・x/0 をコードで返す）</summary>
private static ErrorCode Divide(decimal numerator, decimal denominator, out decimal result)
{
    if (denominator == 0)
    {
        result = 0;
        return (numerator == 0) ? ErrorCode.Undefined : ErrorCode.DivideByZero;
    }
    result = numerator / denominator;
    return ErrorCode.Success;
}


/// <summary>アプリ全体で使用する定数</summary>
internal static class Constants
{
    /// <summary>フォントサイズ関連の定数</summary>
    internal static class FontSize
    {
        /// <summary>エラー表示時の結果欄フォントサイズ</summary>
        internal const float ERROR_MESSAGE = 20.0f;

        /// <summary>結果表示欄の基準フォントサイズ</summary>
        internal const float RESULT_DISPLAY_BASE = 36f;

        /// <summary>途中式表示欄の基準フォントサイズ</summary>
        internal const float EXPRESSION_DISPLAY_BASE = 10f;

        /// <summary>自動縮小で下げる最小フォントサイズ</summary>
        internal const float MIN_LIMIT = 14f;

        /// <summary>フォント縮小時のステップ幅（見た目調整用）</summary>
        internal const float REDUCTION_STEP = 0.5f;

        /// <summary>フォントの再設定を行うか判定するための差分しきい値</summary>
        internal const float SIZE_EPSILON = 0.1f;
    }

    /// <summary>画面表示に使う演算子記号</summary>
    internal static class Symbol
    {
        /// <summary>加算記号</summary>
        internal const string ADD = "+";

        /// <summary>減算記号</summary>
        internal const string SUBTRACT = "-";

        /// <summary>乗算記号（×）</summary>
        internal const string MULTIPLY = "×";

        /// <summary>除算記号（÷）</summary>
        internal const string DIVIDE = "÷";

        /// <summary>等号記号（=）</summary>
        internal const string EQUAL = "=";
    }

    /// <summary>数値・丸め・表示桁に関する定数</summary>
    internal static class Numeric
    {
        /// <summary>各レジスタの初期値（0）</summary>
        internal const decimal INITIAL_VALUE = 0m;

        /// <summary>ゼロ表示の文字列</summary>
        public const string ZERO_VALUE = "0";

        /// <summary>パーセント演算で掛ける係数（r/100）</summary>
        internal const decimal PERCENT_MULTIPLY = 0.01m;

        /// <summary>通常表示で許可する整数部の最大桁数（指数切替の目安）</summary>
        internal const int MAX_INTEGER_DISPLAY_DIGITS = 16;

        /// <summary>0.x 形式のときの小数部最大桁数（先頭0を除いた有効桁の上限）</summary>
        internal const int MAX_FRACTION_DISPLAY_DIGITS_LEADING_ZERO = 17;

        /// <summary>固定小数での有効桁数上限（Windows 電卓準拠）</summary>
        public const int MAX_SIGNIFICANT_DIGITS = 17;

        /// <summary>これ未満の絶対値は指数表示へ切り替える下限閾値</summary>
        internal static readonly decimal SCI_SMALL_THRESHOLD = 1e-9m;

        /// <summary>これ以上の絶対値は指数表示へ切り替える上限閾値</summary>
        internal static readonly decimal SCI_LARGE_THRESHOLD = 1e16m;

        /// <summary>指数表示時に保持する有効桁数</summary>
        public const int EXP_SIGNIFICANT_DIGITS = 16;
    }

    /// <summary>エラー表示用の定数メッセージ</summary>
    internal static class ErrorMessage
    {
        /// <summary>演算結果が型の表現範囲を超えた場合のメッセージ</summary>
        internal const string OVERFLOW = "計算範囲を超えました";

        /// <summary>0除算時のメッセージ</summary>
        internal const string DIVIDE_BY_ZERO = "0で割ることはできません";

        /// <summary>0÷0 等で結果が定義できない場合のメッセージ</summary>
        internal const string UNDEFINED = "結果が定義されていません";
    }

    /// <summary>特殊表示（関数名など）の文字列</summary>
    internal static class SpecialDisplay
    {
        /// <summary>±キーでの符号反転を表す擬似関数名</summary>
        internal const string NEGATE_FUNCTION = "negate";
    }
}
